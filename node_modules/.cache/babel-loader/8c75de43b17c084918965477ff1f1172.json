{"ast":null,"code":"/**\r\n * An API for getting cryptographically-secure random bytes. The bytes are\r\n * generated using the Fortuna algorithm devised by Bruce Schneier and\r\n * Niels Ferguson.\r\n *\r\n * Getting strong random bytes is not yet easy to do in javascript. The only\r\n * truish random entropy that can be collected is from the mouse, keyboard, or\r\n * from timing with respect to page loads, etc. This generator makes a poor\r\n * attempt at providing random bytes when those sources haven't yet provided\r\n * enough entropy to initially seed or to reseed the PRNG.\r\n *\r\n * @author Dave Longley\r\n *\r\n * Copyright (c) 2009-2014 Digital Bazaar, Inc.\r\n */\nvar forge = require('./forge');\n\nrequire('./aes');\n\nrequire('./sha256');\n\nrequire('./prng');\n\nrequire('./util');\n\n(function () {\n  // forge.random already defined\n  if (forge.random && forge.random.getBytes) {\n    module.exports = forge.random;\n    return;\n  }\n\n  (function (jQuery) {\n    // the default prng plugin, uses AES-128\n    var prng_aes = {};\n\n    var _prng_aes_output = new Array(4);\n\n    var _prng_aes_buffer = forge.util.createBuffer();\n\n    prng_aes.formatKey = function (key) {\n      // convert the key into 32-bit integers\n      var tmp = forge.util.createBuffer(key);\n      key = new Array(4);\n      key[0] = tmp.getInt32();\n      key[1] = tmp.getInt32();\n      key[2] = tmp.getInt32();\n      key[3] = tmp.getInt32(); // return the expanded key\n\n      return forge.aes._expandKey(key, false);\n    };\n\n    prng_aes.formatSeed = function (seed) {\n      // convert seed into 32-bit integers\n      var tmp = forge.util.createBuffer(seed);\n      seed = new Array(4);\n      seed[0] = tmp.getInt32();\n      seed[1] = tmp.getInt32();\n      seed[2] = tmp.getInt32();\n      seed[3] = tmp.getInt32();\n      return seed;\n    };\n\n    prng_aes.cipher = function (key, seed) {\n      forge.aes._updateBlock(key, seed, _prng_aes_output, false);\n\n      _prng_aes_buffer.putInt32(_prng_aes_output[0]);\n\n      _prng_aes_buffer.putInt32(_prng_aes_output[1]);\n\n      _prng_aes_buffer.putInt32(_prng_aes_output[2]);\n\n      _prng_aes_buffer.putInt32(_prng_aes_output[3]);\n\n      return _prng_aes_buffer.getBytes();\n    };\n\n    prng_aes.increment = function (seed) {\n      // FIXME: do we care about carry or signed issues?\n      ++seed[3];\n      return seed;\n    };\n\n    prng_aes.md = forge.md.sha256;\n    /**\r\n     * Creates a new PRNG.\r\n     */\n\n    function spawnPrng() {\n      var ctx = forge.prng.create(prng_aes);\n      /**\r\n       * Gets random bytes. If a native secure crypto API is unavailable, this\r\n       * method tries to make the bytes more unpredictable by drawing from data that\r\n       * can be collected from the user of the browser, eg: mouse movement.\r\n       *\r\n       * If a callback is given, this method will be called asynchronously.\r\n       *\r\n       * @param count the number of random bytes to get.\r\n       * @param [callback(err, bytes)] called once the operation completes.\r\n       *\r\n       * @return the random bytes in a string.\r\n       */\n\n      ctx.getBytes = function (count, callback) {\n        return ctx.generate(count, callback);\n      };\n      /**\r\n       * Gets random bytes asynchronously. If a native secure crypto API is\r\n       * unavailable, this method tries to make the bytes more unpredictable by\r\n       * drawing from data that can be collected from the user of the browser,\r\n       * eg: mouse movement.\r\n       *\r\n       * @param count the number of random bytes to get.\r\n       *\r\n       * @return the random bytes in a string.\r\n       */\n\n\n      ctx.getBytesSync = function (count) {\n        return ctx.generate(count);\n      };\n\n      return ctx;\n    } // create default prng context\n\n\n    var _ctx = spawnPrng(); // add other sources of entropy only if window.crypto.getRandomValues is not\n    // available -- otherwise this source will be automatically used by the prng\n\n\n    var getRandomValues = null;\n    var globalScope = forge.util.globalScope;\n\n    var _crypto = globalScope.crypto || globalScope.msCrypto;\n\n    if (_crypto && _crypto.getRandomValues) {\n      getRandomValues = function (arr) {\n        return _crypto.getRandomValues(arr);\n      };\n    }\n\n    if (forge.options.usePureJavaScript || !forge.util.isNodejs && !getRandomValues) {\n      // if this is a web worker, do not use weak entropy, instead register to\n      // receive strong entropy asynchronously from the main thread\n      if (typeof window === 'undefined' || window.document === undefined) {// FIXME:\n      } // get load time entropy\n\n\n      _ctx.collectInt(+new Date(), 32); // add some entropy from navigator object\n\n\n      if (typeof navigator !== 'undefined') {\n        var _navBytes = '';\n\n        for (var key in navigator) {\n          try {\n            if (typeof navigator[key] == 'string') {\n              _navBytes += navigator[key];\n            }\n          } catch (e) {\n            /* Some navigator keys might not be accessible, e.g. the geolocation\r\n              attribute throws an exception if touched in Mozilla chrome://\r\n              context.\r\n                Silently ignore this and just don't use this as a source of\r\n              entropy. */\n          }\n        }\n\n        _ctx.collect(_navBytes);\n\n        _navBytes = null;\n      } // add mouse and keyboard collectors if jquery is available\n\n\n      if (jQuery) {\n        // set up mouse entropy capture\n        jQuery().mousemove(function (e) {\n          // add mouse coords\n          _ctx.collectInt(e.clientX, 16);\n\n          _ctx.collectInt(e.clientY, 16);\n        }); // set up keyboard entropy capture\n\n        jQuery().keypress(function (e) {\n          _ctx.collectInt(e.charCode, 8);\n        });\n      }\n    }\n    /* Random API */\n\n\n    if (!forge.random) {\n      forge.random = _ctx;\n    } else {\n      // extend forge.random with _ctx\n      for (var key in _ctx) {\n        forge.random[key] = _ctx[key];\n      }\n    } // expose spawn PRNG\n\n\n    forge.random.createInstance = spawnPrng;\n    module.exports = forge.random;\n  })(typeof jQuery !== 'undefined' ? jQuery : null);\n})();","map":{"version":3,"sources":["C:/Users/ibott/MajorGroupProject/node_modules/node-forge/lib/random.js"],"names":["forge","require","random","getBytes","module","exports","jQuery","prng_aes","_prng_aes_output","Array","_prng_aes_buffer","util","createBuffer","formatKey","key","tmp","getInt32","aes","_expandKey","formatSeed","seed","cipher","_updateBlock","putInt32","increment","md","sha256","spawnPrng","ctx","prng","create","count","callback","generate","getBytesSync","_ctx","getRandomValues","globalScope","_crypto","crypto","msCrypto","arr","options","usePureJavaScript","isNodejs","window","document","undefined","collectInt","Date","navigator","_navBytes","e","collect","mousemove","clientX","clientY","keypress","charCode","createInstance"],"mappings":"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","sourcesContent":["/**\r\n * An API for getting cryptographically-secure random bytes. The bytes are\r\n * generated using the Fortuna algorithm devised by Bruce Schneier and\r\n * Niels Ferguson.\r\n *\r\n * Getting strong random bytes is not yet easy to do in javascript. The only\r\n * truish random entropy that can be collected is from the mouse, keyboard, or\r\n * from timing with respect to page loads, etc. This generator makes a poor\r\n * attempt at providing random bytes when those sources haven't yet provided\r\n * enough entropy to initially seed or to reseed the PRNG.\r\n *\r\n * @author Dave Longley\r\n *\r\n * Copyright (c) 2009-2014 Digital Bazaar, Inc.\r\n */\r\nvar forge = require('./forge');\r\nrequire('./aes');\r\nrequire('./sha256');\r\nrequire('./prng');\r\nrequire('./util');\r\n\r\n(function() {\r\n\r\n// forge.random already defined\r\nif(forge.random && forge.random.getBytes) {\r\n  module.exports = forge.random;\r\n  return;\r\n}\r\n\r\n(function(jQuery) {\r\n\r\n// the default prng plugin, uses AES-128\r\nvar prng_aes = {};\r\nvar _prng_aes_output = new Array(4);\r\nvar _prng_aes_buffer = forge.util.createBuffer();\r\nprng_aes.formatKey = function(key) {\r\n  // convert the key into 32-bit integers\r\n  var tmp = forge.util.createBuffer(key);\r\n  key = new Array(4);\r\n  key[0] = tmp.getInt32();\r\n  key[1] = tmp.getInt32();\r\n  key[2] = tmp.getInt32();\r\n  key[3] = tmp.getInt32();\r\n\r\n  // return the expanded key\r\n  return forge.aes._expandKey(key, false);\r\n};\r\nprng_aes.formatSeed = function(seed) {\r\n  // convert seed into 32-bit integers\r\n  var tmp = forge.util.createBuffer(seed);\r\n  seed = new Array(4);\r\n  seed[0] = tmp.getInt32();\r\n  seed[1] = tmp.getInt32();\r\n  seed[2] = tmp.getInt32();\r\n  seed[3] = tmp.getInt32();\r\n  return seed;\r\n};\r\nprng_aes.cipher = function(key, seed) {\r\n  forge.aes._updateBlock(key, seed, _prng_aes_output, false);\r\n  _prng_aes_buffer.putInt32(_prng_aes_output[0]);\r\n  _prng_aes_buffer.putInt32(_prng_aes_output[1]);\r\n  _prng_aes_buffer.putInt32(_prng_aes_output[2]);\r\n  _prng_aes_buffer.putInt32(_prng_aes_output[3]);\r\n  return _prng_aes_buffer.getBytes();\r\n};\r\nprng_aes.increment = function(seed) {\r\n  // FIXME: do we care about carry or signed issues?\r\n  ++seed[3];\r\n  return seed;\r\n};\r\nprng_aes.md = forge.md.sha256;\r\n\r\n/**\r\n * Creates a new PRNG.\r\n */\r\nfunction spawnPrng() {\r\n  var ctx = forge.prng.create(prng_aes);\r\n\r\n  /**\r\n   * Gets random bytes. If a native secure crypto API is unavailable, this\r\n   * method tries to make the bytes more unpredictable by drawing from data that\r\n   * can be collected from the user of the browser, eg: mouse movement.\r\n   *\r\n   * If a callback is given, this method will be called asynchronously.\r\n   *\r\n   * @param count the number of random bytes to get.\r\n   * @param [callback(err, bytes)] called once the operation completes.\r\n   *\r\n   * @return the random bytes in a string.\r\n   */\r\n  ctx.getBytes = function(count, callback) {\r\n    return ctx.generate(count, callback);\r\n  };\r\n\r\n  /**\r\n   * Gets random bytes asynchronously. If a native secure crypto API is\r\n   * unavailable, this method tries to make the bytes more unpredictable by\r\n   * drawing from data that can be collected from the user of the browser,\r\n   * eg: mouse movement.\r\n   *\r\n   * @param count the number of random bytes to get.\r\n   *\r\n   * @return the random bytes in a string.\r\n   */\r\n  ctx.getBytesSync = function(count) {\r\n    return ctx.generate(count);\r\n  };\r\n\r\n  return ctx;\r\n}\r\n\r\n// create default prng context\r\nvar _ctx = spawnPrng();\r\n\r\n// add other sources of entropy only if window.crypto.getRandomValues is not\r\n// available -- otherwise this source will be automatically used by the prng\r\nvar getRandomValues = null;\r\nvar globalScope = forge.util.globalScope;\r\nvar _crypto = globalScope.crypto || globalScope.msCrypto;\r\nif(_crypto && _crypto.getRandomValues) {\r\n  getRandomValues = function(arr) {\r\n    return _crypto.getRandomValues(arr);\r\n  };\r\n}\r\n\r\nif(forge.options.usePureJavaScript ||\r\n  (!forge.util.isNodejs && !getRandomValues)) {\r\n  // if this is a web worker, do not use weak entropy, instead register to\r\n  // receive strong entropy asynchronously from the main thread\r\n  if(typeof window === 'undefined' || window.document === undefined) {\r\n    // FIXME:\r\n  }\r\n\r\n  // get load time entropy\r\n  _ctx.collectInt(+new Date(), 32);\r\n\r\n  // add some entropy from navigator object\r\n  if(typeof(navigator) !== 'undefined') {\r\n    var _navBytes = '';\r\n    for(var key in navigator) {\r\n      try {\r\n        if(typeof(navigator[key]) == 'string') {\r\n          _navBytes += navigator[key];\r\n        }\r\n      } catch(e) {\r\n        /* Some navigator keys might not be accessible, e.g. the geolocation\r\n          attribute throws an exception if touched in Mozilla chrome://\r\n          context.\r\n\r\n          Silently ignore this and just don't use this as a source of\r\n          entropy. */\r\n      }\r\n    }\r\n    _ctx.collect(_navBytes);\r\n    _navBytes = null;\r\n  }\r\n\r\n  // add mouse and keyboard collectors if jquery is available\r\n  if(jQuery) {\r\n    // set up mouse entropy capture\r\n    jQuery().mousemove(function(e) {\r\n      // add mouse coords\r\n      _ctx.collectInt(e.clientX, 16);\r\n      _ctx.collectInt(e.clientY, 16);\r\n    });\r\n\r\n    // set up keyboard entropy capture\r\n    jQuery().keypress(function(e) {\r\n      _ctx.collectInt(e.charCode, 8);\r\n    });\r\n  }\r\n}\r\n\r\n/* Random API */\r\nif(!forge.random) {\r\n  forge.random = _ctx;\r\n} else {\r\n  // extend forge.random with _ctx\r\n  for(var key in _ctx) {\r\n    forge.random[key] = _ctx[key];\r\n  }\r\n}\r\n\r\n// expose spawn PRNG\r\nforge.random.createInstance = spawnPrng;\r\n\r\nmodule.exports = forge.random;\r\n\r\n})(typeof(jQuery) !== 'undefined' ? jQuery : null);\r\n\r\n})();\r\n"]},"metadata":{},"sourceType":"script"}