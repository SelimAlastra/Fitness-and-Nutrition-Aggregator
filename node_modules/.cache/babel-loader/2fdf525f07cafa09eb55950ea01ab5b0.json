{"ast":null,"code":"\"use strict\"; // Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AwsRequestSigner = void 0;\n\nconst crypto_1 = require(\"../crypto/crypto\");\n/** AWS Signature Version 4 signing algorithm identifier.  */\n\n\nconst AWS_ALGORITHM = 'AWS4-HMAC-SHA256';\n/**\r\n * The termination string for the AWS credential scope value as defined in\r\n * https://docs.aws.amazon.com/general/latest/gr/sigv4-create-string-to-sign.html\r\n */\n\nconst AWS_REQUEST_TYPE = 'aws4_request';\n/**\r\n * Implements an AWS API request signer based on the AWS Signature Version 4\r\n * signing process.\r\n * https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html\r\n */\n\nclass AwsRequestSigner {\n  /**\r\n   * Instantiates an AWS API request signer used to send authenticated signed\r\n   * requests to AWS APIs based on the AWS Signature Version 4 signing process.\r\n   * This also provides a mechanism to generate the signed request without\r\n   * sending it.\r\n   * @param getCredentials A mechanism to retrieve AWS security credentials\r\n   *   when needed.\r\n   * @param region The AWS region to use.\r\n   */\n  constructor(getCredentials, region) {\n    this.getCredentials = getCredentials;\n    this.region = region;\n    this.crypto = crypto_1.createCrypto();\n  }\n  /**\r\n   * Generates the signed request for the provided HTTP request for calling\r\n   * an AWS API. This follows the steps described at:\r\n   * https://docs.aws.amazon.com/general/latest/gr/sigv4_signing.html\r\n   * @param amzOptions The AWS request options that need to be signed.\r\n   * @return A promise that resolves with the GaxiosOptions containing the\r\n   *   signed HTTP request parameters.\r\n   */\n\n\n  async getRequestOptions(amzOptions) {\n    if (!amzOptions.url) {\n      throw new Error('\"url\" is required in \"amzOptions\"');\n    } // Stringify JSON requests. This will be set in the request body of the\n    // generated signed request.\n\n\n    const requestPayloadData = typeof amzOptions.data === 'object' ? JSON.stringify(amzOptions.data) : amzOptions.data;\n    const url = amzOptions.url;\n    const method = amzOptions.method || 'GET';\n    const requestPayload = amzOptions.body || requestPayloadData;\n    const additionalAmzHeaders = amzOptions.headers;\n    const awsSecurityCredentials = await this.getCredentials();\n    const uri = new URL(url);\n    const headerMap = await generateAuthenticationHeaderMap({\n      crypto: this.crypto,\n      host: uri.host,\n      canonicalUri: uri.pathname,\n      canonicalQuerystring: uri.search.substr(1),\n      method,\n      region: this.region,\n      securityCredentials: awsSecurityCredentials,\n      requestPayload,\n      additionalAmzHeaders\n    }); // Append additional optional headers, eg. X-Amz-Target, Content-Type, etc.\n\n    const headers = Object.assign( // Add x-amz-date if available.\n    headerMap.amzDate ? {\n      'x-amz-date': headerMap.amzDate\n    } : {}, {\n      Authorization: headerMap.authorizationHeader,\n      host: uri.host\n    }, additionalAmzHeaders || {});\n\n    if (awsSecurityCredentials.token) {\n      Object.assign(headers, {\n        'x-amz-security-token': awsSecurityCredentials.token\n      });\n    }\n\n    const awsSignedReq = {\n      url,\n      method: method,\n      headers\n    };\n\n    if (typeof requestPayload !== 'undefined') {\n      awsSignedReq.body = requestPayload;\n    }\n\n    return awsSignedReq;\n  }\n\n}\n\nexports.AwsRequestSigner = AwsRequestSigner;\n/**\r\n * Creates the HMAC-SHA256 hash of the provided message using the\r\n * provided key.\r\n *\r\n * @param crypto The crypto instance used to facilitate cryptographic\r\n *   operations.\r\n * @param key The HMAC-SHA256 key to use.\r\n * @param msg The message to hash.\r\n * @return The computed hash bytes.\r\n */\n\nasync function sign(crypto, key, msg) {\n  return await crypto.signWithHmacSha256(key, msg);\n}\n/**\r\n * Calculates the signing key used to calculate the signature for\r\n * AWS Signature Version 4 based on:\r\n * https://docs.aws.amazon.com/general/latest/gr/sigv4-calculate-signature.html\r\n *\r\n * @param crypto The crypto instance used to facilitate cryptographic\r\n *   operations.\r\n * @param key The AWS secret access key.\r\n * @param dateStamp The '%Y%m%d' date format.\r\n * @param region The AWS region.\r\n * @param serviceName The AWS service name, eg. sts.\r\n * @return The signing key bytes.\r\n */\n\n\nasync function getSigningKey(crypto, key, dateStamp, region, serviceName) {\n  const kDate = await sign(crypto, `AWS4${key}`, dateStamp);\n  const kRegion = await sign(crypto, kDate, region);\n  const kService = await sign(crypto, kRegion, serviceName);\n  const kSigning = await sign(crypto, kService, 'aws4_request');\n  return kSigning;\n}\n/**\r\n * Generates the authentication header map needed for generating the AWS\r\n * Signature Version 4 signed request.\r\n *\r\n * @param option The options needed to compute the authentication header map.\r\n * @return The AWS authentication header map which constitutes of the following\r\n *   components: amz-date, authorization header and canonical query string.\r\n */\n\n\nasync function generateAuthenticationHeaderMap(options) {\n  const additionalAmzHeaders = options.additionalAmzHeaders || {};\n  const requestPayload = options.requestPayload || ''; // iam.amazonaws.com host => iam service.\n  // sts.us-east-2.amazonaws.com => sts service.\n\n  const serviceName = options.host.split('.')[0];\n  const now = new Date(); // Format: '%Y%m%dT%H%M%SZ'.\n\n  const amzDate = now.toISOString().replace(/[-:]/g, '').replace(/\\.[0-9]+/, ''); // Format: '%Y%m%d'.\n\n  const dateStamp = now.toISOString().replace(/[-]/g, '').replace(/T.*/, ''); // Change all additional headers to be lower case.\n\n  const reformattedAdditionalAmzHeaders = {};\n  Object.keys(additionalAmzHeaders).forEach(key => {\n    reformattedAdditionalAmzHeaders[key.toLowerCase()] = additionalAmzHeaders[key];\n  }); // Add AWS token if available.\n\n  if (options.securityCredentials.token) {\n    reformattedAdditionalAmzHeaders['x-amz-security-token'] = options.securityCredentials.token;\n  } // Header keys need to be sorted alphabetically.\n\n\n  const amzHeaders = Object.assign({\n    host: options.host\n  }, // Previously the date was not fixed with x-amz- and could be provided manually.\n  // https://github.com/boto/botocore/blob/879f8440a4e9ace5d3cf145ce8b3d5e5ffb892ef/tests/unit/auth/aws4_testsuite/get-header-value-trim.req\n  reformattedAdditionalAmzHeaders.date ? {} : {\n    'x-amz-date': amzDate\n  }, reformattedAdditionalAmzHeaders);\n  let canonicalHeaders = '';\n  const signedHeadersList = Object.keys(amzHeaders).sort();\n  signedHeadersList.forEach(key => {\n    canonicalHeaders += `${key}:${amzHeaders[key]}\\n`;\n  });\n  const signedHeaders = signedHeadersList.join(';');\n  const payloadHash = await options.crypto.sha256DigestHex(requestPayload); // https://docs.aws.amazon.com/general/latest/gr/sigv4-create-canonical-request.html\n\n  const canonicalRequest = `${options.method}\\n` + `${options.canonicalUri}\\n` + `${options.canonicalQuerystring}\\n` + `${canonicalHeaders}\\n` + `${signedHeaders}\\n` + `${payloadHash}`;\n  const credentialScope = `${dateStamp}/${options.region}/${serviceName}/${AWS_REQUEST_TYPE}`; // https://docs.aws.amazon.com/general/latest/gr/sigv4-create-string-to-sign.html\n\n  const stringToSign = `${AWS_ALGORITHM}\\n` + `${amzDate}\\n` + `${credentialScope}\\n` + (await options.crypto.sha256DigestHex(canonicalRequest)); // https://docs.aws.amazon.com/general/latest/gr/sigv4-calculate-signature.html\n\n  const signingKey = await getSigningKey(options.crypto, options.securityCredentials.secretAccessKey, dateStamp, options.region, serviceName);\n  const signature = await sign(options.crypto, signingKey, stringToSign); // https://docs.aws.amazon.com/general/latest/gr/sigv4-add-signature-to-request.html\n\n  const authorizationHeader = `${AWS_ALGORITHM} Credential=${options.securityCredentials.accessKeyId}/` + `${credentialScope}, SignedHeaders=${signedHeaders}, ` + `Signature=${crypto_1.fromArrayBufferToHex(signature)}`;\n  return {\n    // Do not return x-amz-date if date is available.\n    amzDate: reformattedAdditionalAmzHeaders.date ? undefined : amzDate,\n    authorizationHeader,\n    canonicalQuerystring: options.canonicalQuerystring\n  };\n}","map":{"version":3,"sources":["C:/Users/ibott/MajorGroupProject/node_modules/google-auth-library/build/src/auth/awsrequestsigner.js"],"names":["Object","defineProperty","exports","value","AwsRequestSigner","crypto_1","require","AWS_ALGORITHM","AWS_REQUEST_TYPE","constructor","getCredentials","region","crypto","createCrypto","getRequestOptions","amzOptions","url","Error","requestPayloadData","data","JSON","stringify","method","requestPayload","body","additionalAmzHeaders","headers","awsSecurityCredentials","uri","URL","headerMap","generateAuthenticationHeaderMap","host","canonicalUri","pathname","canonicalQuerystring","search","substr","securityCredentials","assign","amzDate","Authorization","authorizationHeader","token","awsSignedReq","sign","key","msg","signWithHmacSha256","getSigningKey","dateStamp","serviceName","kDate","kRegion","kService","kSigning","options","split","now","Date","toISOString","replace","reformattedAdditionalAmzHeaders","keys","forEach","toLowerCase","amzHeaders","date","canonicalHeaders","signedHeadersList","sort","signedHeaders","join","payloadHash","sha256DigestHex","canonicalRequest","credentialScope","stringToSign","signingKey","secretAccessKey","signature","accessKeyId","fromArrayBufferToHex","undefined"],"mappings":"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","sourcesContent":["\"use strict\";\r\n// Copyright 2021 Google LLC\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.AwsRequestSigner = void 0;\r\nconst crypto_1 = require(\"../crypto/crypto\");\r\n/** AWS Signature Version 4 signing algorithm identifier.  */\r\nconst AWS_ALGORITHM = 'AWS4-HMAC-SHA256';\r\n/**\r\n * The termination string for the AWS credential scope value as defined in\r\n * https://docs.aws.amazon.com/general/latest/gr/sigv4-create-string-to-sign.html\r\n */\r\nconst AWS_REQUEST_TYPE = 'aws4_request';\r\n/**\r\n * Implements an AWS API request signer based on the AWS Signature Version 4\r\n * signing process.\r\n * https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html\r\n */\r\nclass AwsRequestSigner {\r\n    /**\r\n     * Instantiates an AWS API request signer used to send authenticated signed\r\n     * requests to AWS APIs based on the AWS Signature Version 4 signing process.\r\n     * This also provides a mechanism to generate the signed request without\r\n     * sending it.\r\n     * @param getCredentials A mechanism to retrieve AWS security credentials\r\n     *   when needed.\r\n     * @param region The AWS region to use.\r\n     */\r\n    constructor(getCredentials, region) {\r\n        this.getCredentials = getCredentials;\r\n        this.region = region;\r\n        this.crypto = crypto_1.createCrypto();\r\n    }\r\n    /**\r\n     * Generates the signed request for the provided HTTP request for calling\r\n     * an AWS API. This follows the steps described at:\r\n     * https://docs.aws.amazon.com/general/latest/gr/sigv4_signing.html\r\n     * @param amzOptions The AWS request options that need to be signed.\r\n     * @return A promise that resolves with the GaxiosOptions containing the\r\n     *   signed HTTP request parameters.\r\n     */\r\n    async getRequestOptions(amzOptions) {\r\n        if (!amzOptions.url) {\r\n            throw new Error('\"url\" is required in \"amzOptions\"');\r\n        }\r\n        // Stringify JSON requests. This will be set in the request body of the\r\n        // generated signed request.\r\n        const requestPayloadData = typeof amzOptions.data === 'object'\r\n            ? JSON.stringify(amzOptions.data)\r\n            : amzOptions.data;\r\n        const url = amzOptions.url;\r\n        const method = amzOptions.method || 'GET';\r\n        const requestPayload = amzOptions.body || requestPayloadData;\r\n        const additionalAmzHeaders = amzOptions.headers;\r\n        const awsSecurityCredentials = await this.getCredentials();\r\n        const uri = new URL(url);\r\n        const headerMap = await generateAuthenticationHeaderMap({\r\n            crypto: this.crypto,\r\n            host: uri.host,\r\n            canonicalUri: uri.pathname,\r\n            canonicalQuerystring: uri.search.substr(1),\r\n            method,\r\n            region: this.region,\r\n            securityCredentials: awsSecurityCredentials,\r\n            requestPayload,\r\n            additionalAmzHeaders,\r\n        });\r\n        // Append additional optional headers, eg. X-Amz-Target, Content-Type, etc.\r\n        const headers = Object.assign(\r\n        // Add x-amz-date if available.\r\n        headerMap.amzDate ? { 'x-amz-date': headerMap.amzDate } : {}, {\r\n            Authorization: headerMap.authorizationHeader,\r\n            host: uri.host,\r\n        }, additionalAmzHeaders || {});\r\n        if (awsSecurityCredentials.token) {\r\n            Object.assign(headers, {\r\n                'x-amz-security-token': awsSecurityCredentials.token,\r\n            });\r\n        }\r\n        const awsSignedReq = {\r\n            url,\r\n            method: method,\r\n            headers,\r\n        };\r\n        if (typeof requestPayload !== 'undefined') {\r\n            awsSignedReq.body = requestPayload;\r\n        }\r\n        return awsSignedReq;\r\n    }\r\n}\r\nexports.AwsRequestSigner = AwsRequestSigner;\r\n/**\r\n * Creates the HMAC-SHA256 hash of the provided message using the\r\n * provided key.\r\n *\r\n * @param crypto The crypto instance used to facilitate cryptographic\r\n *   operations.\r\n * @param key The HMAC-SHA256 key to use.\r\n * @param msg The message to hash.\r\n * @return The computed hash bytes.\r\n */\r\nasync function sign(crypto, key, msg) {\r\n    return await crypto.signWithHmacSha256(key, msg);\r\n}\r\n/**\r\n * Calculates the signing key used to calculate the signature for\r\n * AWS Signature Version 4 based on:\r\n * https://docs.aws.amazon.com/general/latest/gr/sigv4-calculate-signature.html\r\n *\r\n * @param crypto The crypto instance used to facilitate cryptographic\r\n *   operations.\r\n * @param key The AWS secret access key.\r\n * @param dateStamp The '%Y%m%d' date format.\r\n * @param region The AWS region.\r\n * @param serviceName The AWS service name, eg. sts.\r\n * @return The signing key bytes.\r\n */\r\nasync function getSigningKey(crypto, key, dateStamp, region, serviceName) {\r\n    const kDate = await sign(crypto, `AWS4${key}`, dateStamp);\r\n    const kRegion = await sign(crypto, kDate, region);\r\n    const kService = await sign(crypto, kRegion, serviceName);\r\n    const kSigning = await sign(crypto, kService, 'aws4_request');\r\n    return kSigning;\r\n}\r\n/**\r\n * Generates the authentication header map needed for generating the AWS\r\n * Signature Version 4 signed request.\r\n *\r\n * @param option The options needed to compute the authentication header map.\r\n * @return The AWS authentication header map which constitutes of the following\r\n *   components: amz-date, authorization header and canonical query string.\r\n */\r\nasync function generateAuthenticationHeaderMap(options) {\r\n    const additionalAmzHeaders = options.additionalAmzHeaders || {};\r\n    const requestPayload = options.requestPayload || '';\r\n    // iam.amazonaws.com host => iam service.\r\n    // sts.us-east-2.amazonaws.com => sts service.\r\n    const serviceName = options.host.split('.')[0];\r\n    const now = new Date();\r\n    // Format: '%Y%m%dT%H%M%SZ'.\r\n    const amzDate = now\r\n        .toISOString()\r\n        .replace(/[-:]/g, '')\r\n        .replace(/\\.[0-9]+/, '');\r\n    // Format: '%Y%m%d'.\r\n    const dateStamp = now.toISOString().replace(/[-]/g, '').replace(/T.*/, '');\r\n    // Change all additional headers to be lower case.\r\n    const reformattedAdditionalAmzHeaders = {};\r\n    Object.keys(additionalAmzHeaders).forEach(key => {\r\n        reformattedAdditionalAmzHeaders[key.toLowerCase()] =\r\n            additionalAmzHeaders[key];\r\n    });\r\n    // Add AWS token if available.\r\n    if (options.securityCredentials.token) {\r\n        reformattedAdditionalAmzHeaders['x-amz-security-token'] =\r\n            options.securityCredentials.token;\r\n    }\r\n    // Header keys need to be sorted alphabetically.\r\n    const amzHeaders = Object.assign({\r\n        host: options.host,\r\n    }, \r\n    // Previously the date was not fixed with x-amz- and could be provided manually.\r\n    // https://github.com/boto/botocore/blob/879f8440a4e9ace5d3cf145ce8b3d5e5ffb892ef/tests/unit/auth/aws4_testsuite/get-header-value-trim.req\r\n    reformattedAdditionalAmzHeaders.date ? {} : { 'x-amz-date': amzDate }, reformattedAdditionalAmzHeaders);\r\n    let canonicalHeaders = '';\r\n    const signedHeadersList = Object.keys(amzHeaders).sort();\r\n    signedHeadersList.forEach(key => {\r\n        canonicalHeaders += `${key}:${amzHeaders[key]}\\n`;\r\n    });\r\n    const signedHeaders = signedHeadersList.join(';');\r\n    const payloadHash = await options.crypto.sha256DigestHex(requestPayload);\r\n    // https://docs.aws.amazon.com/general/latest/gr/sigv4-create-canonical-request.html\r\n    const canonicalRequest = `${options.method}\\n` +\r\n        `${options.canonicalUri}\\n` +\r\n        `${options.canonicalQuerystring}\\n` +\r\n        `${canonicalHeaders}\\n` +\r\n        `${signedHeaders}\\n` +\r\n        `${payloadHash}`;\r\n    const credentialScope = `${dateStamp}/${options.region}/${serviceName}/${AWS_REQUEST_TYPE}`;\r\n    // https://docs.aws.amazon.com/general/latest/gr/sigv4-create-string-to-sign.html\r\n    const stringToSign = `${AWS_ALGORITHM}\\n` +\r\n        `${amzDate}\\n` +\r\n        `${credentialScope}\\n` +\r\n        (await options.crypto.sha256DigestHex(canonicalRequest));\r\n    // https://docs.aws.amazon.com/general/latest/gr/sigv4-calculate-signature.html\r\n    const signingKey = await getSigningKey(options.crypto, options.securityCredentials.secretAccessKey, dateStamp, options.region, serviceName);\r\n    const signature = await sign(options.crypto, signingKey, stringToSign);\r\n    // https://docs.aws.amazon.com/general/latest/gr/sigv4-add-signature-to-request.html\r\n    const authorizationHeader = `${AWS_ALGORITHM} Credential=${options.securityCredentials.accessKeyId}/` +\r\n        `${credentialScope}, SignedHeaders=${signedHeaders}, ` +\r\n        `Signature=${crypto_1.fromArrayBufferToHex(signature)}`;\r\n    return {\r\n        // Do not return x-amz-date if date is available.\r\n        amzDate: reformattedAdditionalAmzHeaders.date ? undefined : amzDate,\r\n        authorizationHeader,\r\n        canonicalQuerystring: options.canonicalQuerystring,\r\n    };\r\n}\r\n//# sourceMappingURL=awsrequestsigner.js.map"]},"metadata":{},"sourceType":"script"}