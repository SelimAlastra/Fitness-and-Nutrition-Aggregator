{"ast":null,"code":"\"use strict\";\n/**\r\n * Copyright 2018 Google LLC\r\n *\r\n * Distributed under MIT license.\r\n * See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\r\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.requestTimeout = exports.resetIsAvailableCache = exports.isAvailable = exports.project = exports.instance = exports.HEADERS = exports.HEADER_VALUE = exports.HEADER_NAME = exports.SECONDARY_HOST_ADDRESS = exports.HOST_ADDRESS = exports.BASE_PATH = void 0;\n\nconst gaxios_1 = require(\"gaxios\");\n\nconst jsonBigint = require('json-bigint'); // eslint-disable-line\n\n\nexports.BASE_PATH = '/computeMetadata/v1';\nexports.HOST_ADDRESS = 'http://169.254.169.254';\nexports.SECONDARY_HOST_ADDRESS = 'http://metadata.google.internal.';\nexports.HEADER_NAME = 'Metadata-Flavor';\nexports.HEADER_VALUE = 'Google';\nexports.HEADERS = Object.freeze({\n  [exports.HEADER_NAME]: exports.HEADER_VALUE\n});\n/**\r\n * Returns the base URL while taking into account the GCE_METADATA_HOST\r\n * environment variable if it exists.\r\n *\r\n * @returns The base URL, e.g., http://169.254.169.254/computeMetadata/v1.\r\n */\n\nfunction getBaseUrl(baseUrl) {\n  if (!baseUrl) {\n    baseUrl = process.env.GCE_METADATA_IP || process.env.GCE_METADATA_HOST || exports.HOST_ADDRESS;\n  } // If no scheme is provided default to HTTP:\n\n\n  if (!/^https?:\\/\\//.test(baseUrl)) {\n    baseUrl = `http://${baseUrl}`;\n  }\n\n  return new URL(exports.BASE_PATH, baseUrl).href;\n} // Accepts an options object passed from the user to the API. In previous\n// versions of the API, it referred to a `Request` or an `Axios` request\n// options object.  Now it refers to an object with very limited property\n// names. This is here to help ensure users don't pass invalid options when\n// they  upgrade from 0.4 to 0.5 to 0.8.\n\n\nfunction validate(options) {\n  Object.keys(options).forEach(key => {\n    switch (key) {\n      case 'params':\n      case 'property':\n      case 'headers':\n        break;\n\n      case 'qs':\n        throw new Error(\"'qs' is not a valid configuration option. Please use 'params' instead.\");\n\n      default:\n        throw new Error(`'${key}' is not a valid configuration option.`);\n    }\n  });\n}\n\nasync function metadataAccessor(type, options, noResponseRetries = 3, fastFail = false) {\n  options = options || {};\n\n  if (typeof options === 'string') {\n    options = {\n      property: options\n    };\n  }\n\n  let property = '';\n\n  if (typeof options === 'object' && options.property) {\n    property = '/' + options.property;\n  }\n\n  validate(options);\n\n  try {\n    const requestMethod = fastFail ? fastFailMetadataRequest : gaxios_1.request;\n    const res = await requestMethod({\n      url: `${getBaseUrl()}/${type}${property}`,\n      headers: Object.assign({}, exports.HEADERS, options.headers),\n      retryConfig: {\n        noResponseRetries\n      },\n      params: options.params,\n      responseType: 'text',\n      timeout: requestTimeout()\n    }); // NOTE: node.js converts all incoming headers to lower case.\n\n    if (res.headers[exports.HEADER_NAME.toLowerCase()] !== exports.HEADER_VALUE) {\n      throw new Error(`Invalid response from metadata service: incorrect ${exports.HEADER_NAME} header.`);\n    } else if (!res.data) {\n      throw new Error('Invalid response from the metadata service');\n    }\n\n    if (typeof res.data === 'string') {\n      try {\n        return jsonBigint.parse(res.data);\n      } catch (_a) {\n        /* ignore */\n      }\n    }\n\n    return res.data;\n  } catch (e) {\n    if (e.response && e.response.status !== 200) {\n      e.message = `Unsuccessful response status code. ${e.message}`;\n    }\n\n    throw e;\n  }\n}\n\nasync function fastFailMetadataRequest(options) {\n  const secondaryOptions = { ...options,\n    url: options.url.replace(getBaseUrl(), getBaseUrl(exports.SECONDARY_HOST_ADDRESS))\n  }; // We race a connection between DNS/IP to metadata server. There are a couple\n  // reasons for this:\n  //\n  // 1. the DNS is slow in some GCP environments; by checking both, we might\n  //    detect the runtime environment signficantly faster.\n  // 2. we can't just check the IP, which is tarpitted and slow to respond\n  //    on a user's local machine.\n  //\n  // Additional logic has been added to make sure that we don't create an\n  // unhandled rejection in scenarios where a failure happens sometime\n  // after a success.\n  //\n  // Note, however, if a failure happens prior to a success, a rejection should\n  // occur, this is for folks running locally.\n  //\n\n  let responded = false;\n  const r1 = gaxios_1.request(options).then(res => {\n    responded = true;\n    return res;\n  }).catch(err => {\n    if (responded) {\n      return r2;\n    } else {\n      responded = true;\n      throw err;\n    }\n  });\n  const r2 = gaxios_1.request(secondaryOptions).then(res => {\n    responded = true;\n    return res;\n  }).catch(err => {\n    if (responded) {\n      return r1;\n    } else {\n      responded = true;\n      throw err;\n    }\n  });\n  return Promise.race([r1, r2]);\n} // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\nfunction instance(options) {\n  return metadataAccessor('instance', options);\n}\n\nexports.instance = instance; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nfunction project(options) {\n  return metadataAccessor('project', options);\n}\n\nexports.project = project;\n/*\r\n * How many times should we retry detecting GCP environment.\r\n */\n\nfunction detectGCPAvailableRetries() {\n  return process.env.DETECT_GCP_RETRIES ? Number(process.env.DETECT_GCP_RETRIES) : 0;\n}\n/**\r\n * Determine if the metadata server is currently available.\r\n */\n\n\nlet cachedIsAvailableResponse;\n\nasync function isAvailable() {\n  try {\n    // If a user is instantiating several GCP libraries at the same time,\n    // this may result in multiple calls to isAvailable(), to detect the\n    // runtime environment. We use the same promise for each of these calls\n    // to reduce the network load.\n    if (cachedIsAvailableResponse === undefined) {\n      cachedIsAvailableResponse = metadataAccessor('instance', undefined, detectGCPAvailableRetries(), // If the default HOST_ADDRESS has been overridden, we should not\n      // make an effort to try SECONDARY_HOST_ADDRESS (as we are likely in\n      // a non-GCP environment):\n      !(process.env.GCE_METADATA_IP || process.env.GCE_METADATA_HOST));\n    }\n\n    await cachedIsAvailableResponse;\n    return true;\n  } catch (err) {\n    if (process.env.DEBUG_AUTH) {\n      console.info(err);\n    }\n\n    if (err.type === 'request-timeout') {\n      // If running in a GCP environment, metadata endpoint should return\n      // within ms.\n      return false;\n    }\n\n    if (err.response && err.response.status === 404) {\n      return false;\n    } else {\n      if (!(err.response && err.response.status === 404) && ( // A warning is emitted if we see an unexpected err.code, or err.code\n      // is not populated:\n      !err.code || !['EHOSTDOWN', 'EHOSTUNREACH', 'ENETUNREACH', 'ENOENT', 'ENOTFOUND', 'ECONNREFUSED'].includes(err.code))) {\n        let code = 'UNKNOWN';\n        if (err.code) code = err.code;\n        process.emitWarning(`received unexpected error = ${err.message} code = ${code}`, 'MetadataLookupWarning');\n      } // Failure to resolve the metadata service means that it is not available.\n\n\n      return false;\n    }\n  }\n}\n\nexports.isAvailable = isAvailable;\n/**\r\n * reset the memoized isAvailable() lookup.\r\n */\n\nfunction resetIsAvailableCache() {\n  cachedIsAvailableResponse = undefined;\n}\n\nexports.resetIsAvailableCache = resetIsAvailableCache;\n\nfunction requestTimeout() {\n  // In testing, we were able to reproduce behavior similar to\n  // https://github.com/googleapis/google-auth-library-nodejs/issues/798\n  // by making many concurrent network requests. Requests do not actually fail,\n  // rather they take significantly longer to complete (and we hit our\n  // default 3000ms timeout).\n  //\n  // This logic detects a GCF environment, using the documented environment\n  // variables K_SERVICE and FUNCTION_NAME:\n  // https://cloud.google.com/functions/docs/env-var and, in a GCF environment\n  // eliminates timeouts (by setting the value to 0 to disable).\n  return process.env.K_SERVICE || process.env.FUNCTION_NAME ? 0 : 3000;\n}\n\nexports.requestTimeout = requestTimeout;","map":{"version":3,"sources":["../../src/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\n/**\r\n * Copyright 2018 Google LLC\r\n *\r\n * Distributed under MIT license.\r\n * See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.requestTimeout = exports.resetIsAvailableCache = exports.isAvailable = exports.project = exports.instance = exports.HEADERS = exports.HEADER_VALUE = exports.HEADER_NAME = exports.SECONDARY_HOST_ADDRESS = exports.HOST_ADDRESS = exports.BASE_PATH = void 0;\r\nconst gaxios_1 = require(\"gaxios\");\r\nconst jsonBigint = require('json-bigint'); // eslint-disable-line\r\nexports.BASE_PATH = '/computeMetadata/v1';\r\nexports.HOST_ADDRESS = 'http://169.254.169.254';\r\nexports.SECONDARY_HOST_ADDRESS = 'http://metadata.google.internal.';\r\nexports.HEADER_NAME = 'Metadata-Flavor';\r\nexports.HEADER_VALUE = 'Google';\r\nexports.HEADERS = Object.freeze({ [exports.HEADER_NAME]: exports.HEADER_VALUE });\r\n/**\r\n * Returns the base URL while taking into account the GCE_METADATA_HOST\r\n * environment variable if it exists.\r\n *\r\n * @returns The base URL, e.g., http://169.254.169.254/computeMetadata/v1.\r\n */\r\nfunction getBaseUrl(baseUrl) {\r\n    if (!baseUrl) {\r\n        baseUrl =\r\n            process.env.GCE_METADATA_IP ||\r\n                process.env.GCE_METADATA_HOST ||\r\n                exports.HOST_ADDRESS;\r\n    }\r\n    // If no scheme is provided default to HTTP:\r\n    if (!/^https?:\\/\\//.test(baseUrl)) {\r\n        baseUrl = `http://${baseUrl}`;\r\n    }\r\n    return new URL(exports.BASE_PATH, baseUrl).href;\r\n}\r\n// Accepts an options object passed from the user to the API. In previous\r\n// versions of the API, it referred to a `Request` or an `Axios` request\r\n// options object.  Now it refers to an object with very limited property\r\n// names. This is here to help ensure users don't pass invalid options when\r\n// they  upgrade from 0.4 to 0.5 to 0.8.\r\nfunction validate(options) {\r\n    Object.keys(options).forEach(key => {\r\n        switch (key) {\r\n            case 'params':\r\n            case 'property':\r\n            case 'headers':\r\n                break;\r\n            case 'qs':\r\n                throw new Error(\"'qs' is not a valid configuration option. Please use 'params' instead.\");\r\n            default:\r\n                throw new Error(`'${key}' is not a valid configuration option.`);\r\n        }\r\n    });\r\n}\r\nasync function metadataAccessor(type, options, noResponseRetries = 3, fastFail = false) {\r\n    options = options || {};\r\n    if (typeof options === 'string') {\r\n        options = { property: options };\r\n    }\r\n    let property = '';\r\n    if (typeof options === 'object' && options.property) {\r\n        property = '/' + options.property;\r\n    }\r\n    validate(options);\r\n    try {\r\n        const requestMethod = fastFail ? fastFailMetadataRequest : gaxios_1.request;\r\n        const res = await requestMethod({\r\n            url: `${getBaseUrl()}/${type}${property}`,\r\n            headers: Object.assign({}, exports.HEADERS, options.headers),\r\n            retryConfig: { noResponseRetries },\r\n            params: options.params,\r\n            responseType: 'text',\r\n            timeout: requestTimeout(),\r\n        });\r\n        // NOTE: node.js converts all incoming headers to lower case.\r\n        if (res.headers[exports.HEADER_NAME.toLowerCase()] !== exports.HEADER_VALUE) {\r\n            throw new Error(`Invalid response from metadata service: incorrect ${exports.HEADER_NAME} header.`);\r\n        }\r\n        else if (!res.data) {\r\n            throw new Error('Invalid response from the metadata service');\r\n        }\r\n        if (typeof res.data === 'string') {\r\n            try {\r\n                return jsonBigint.parse(res.data);\r\n            }\r\n            catch (_a) {\r\n                /* ignore */\r\n            }\r\n        }\r\n        return res.data;\r\n    }\r\n    catch (e) {\r\n        if (e.response && e.response.status !== 200) {\r\n            e.message = `Unsuccessful response status code. ${e.message}`;\r\n        }\r\n        throw e;\r\n    }\r\n}\r\nasync function fastFailMetadataRequest(options) {\r\n    const secondaryOptions = {\r\n        ...options,\r\n        url: options.url.replace(getBaseUrl(), getBaseUrl(exports.SECONDARY_HOST_ADDRESS)),\r\n    };\r\n    // We race a connection between DNS/IP to metadata server. There are a couple\r\n    // reasons for this:\r\n    //\r\n    // 1. the DNS is slow in some GCP environments; by checking both, we might\r\n    //    detect the runtime environment signficantly faster.\r\n    // 2. we can't just check the IP, which is tarpitted and slow to respond\r\n    //    on a user's local machine.\r\n    //\r\n    // Additional logic has been added to make sure that we don't create an\r\n    // unhandled rejection in scenarios where a failure happens sometime\r\n    // after a success.\r\n    //\r\n    // Note, however, if a failure happens prior to a success, a rejection should\r\n    // occur, this is for folks running locally.\r\n    //\r\n    let responded = false;\r\n    const r1 = gaxios_1.request(options)\r\n        .then(res => {\r\n        responded = true;\r\n        return res;\r\n    })\r\n        .catch(err => {\r\n        if (responded) {\r\n            return r2;\r\n        }\r\n        else {\r\n            responded = true;\r\n            throw err;\r\n        }\r\n    });\r\n    const r2 = gaxios_1.request(secondaryOptions)\r\n        .then(res => {\r\n        responded = true;\r\n        return res;\r\n    })\r\n        .catch(err => {\r\n        if (responded) {\r\n            return r1;\r\n        }\r\n        else {\r\n            responded = true;\r\n            throw err;\r\n        }\r\n    });\r\n    return Promise.race([r1, r2]);\r\n}\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nfunction instance(options) {\r\n    return metadataAccessor('instance', options);\r\n}\r\nexports.instance = instance;\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nfunction project(options) {\r\n    return metadataAccessor('project', options);\r\n}\r\nexports.project = project;\r\n/*\r\n * How many times should we retry detecting GCP environment.\r\n */\r\nfunction detectGCPAvailableRetries() {\r\n    return process.env.DETECT_GCP_RETRIES\r\n        ? Number(process.env.DETECT_GCP_RETRIES)\r\n        : 0;\r\n}\r\n/**\r\n * Determine if the metadata server is currently available.\r\n */\r\nlet cachedIsAvailableResponse;\r\nasync function isAvailable() {\r\n    try {\r\n        // If a user is instantiating several GCP libraries at the same time,\r\n        // this may result in multiple calls to isAvailable(), to detect the\r\n        // runtime environment. We use the same promise for each of these calls\r\n        // to reduce the network load.\r\n        if (cachedIsAvailableResponse === undefined) {\r\n            cachedIsAvailableResponse = metadataAccessor('instance', undefined, detectGCPAvailableRetries(), \r\n            // If the default HOST_ADDRESS has been overridden, we should not\r\n            // make an effort to try SECONDARY_HOST_ADDRESS (as we are likely in\r\n            // a non-GCP environment):\r\n            !(process.env.GCE_METADATA_IP || process.env.GCE_METADATA_HOST));\r\n        }\r\n        await cachedIsAvailableResponse;\r\n        return true;\r\n    }\r\n    catch (err) {\r\n        if (process.env.DEBUG_AUTH) {\r\n            console.info(err);\r\n        }\r\n        if (err.type === 'request-timeout') {\r\n            // If running in a GCP environment, metadata endpoint should return\r\n            // within ms.\r\n            return false;\r\n        }\r\n        if (err.response && err.response.status === 404) {\r\n            return false;\r\n        }\r\n        else {\r\n            if (!(err.response && err.response.status === 404) &&\r\n                // A warning is emitted if we see an unexpected err.code, or err.code\r\n                // is not populated:\r\n                (!err.code ||\r\n                    ![\r\n                        'EHOSTDOWN',\r\n                        'EHOSTUNREACH',\r\n                        'ENETUNREACH',\r\n                        'ENOENT',\r\n                        'ENOTFOUND',\r\n                        'ECONNREFUSED',\r\n                    ].includes(err.code))) {\r\n                let code = 'UNKNOWN';\r\n                if (err.code)\r\n                    code = err.code;\r\n                process.emitWarning(`received unexpected error = ${err.message} code = ${code}`, 'MetadataLookupWarning');\r\n            }\r\n            // Failure to resolve the metadata service means that it is not available.\r\n            return false;\r\n        }\r\n    }\r\n}\r\nexports.isAvailable = isAvailable;\r\n/**\r\n * reset the memoized isAvailable() lookup.\r\n */\r\nfunction resetIsAvailableCache() {\r\n    cachedIsAvailableResponse = undefined;\r\n}\r\nexports.resetIsAvailableCache = resetIsAvailableCache;\r\nfunction requestTimeout() {\r\n    // In testing, we were able to reproduce behavior similar to\r\n    // https://github.com/googleapis/google-auth-library-nodejs/issues/798\r\n    // by making many concurrent network requests. Requests do not actually fail,\r\n    // rather they take significantly longer to complete (and we hit our\r\n    // default 3000ms timeout).\r\n    //\r\n    // This logic detects a GCF environment, using the documented environment\r\n    // variables K_SERVICE and FUNCTION_NAME:\r\n    // https://cloud.google.com/functions/docs/env-var and, in a GCF environment\r\n    // eliminates timeouts (by setting the value to 0 to disable).\r\n    return process.env.K_SERVICE || process.env.FUNCTION_NAME ? 0 : 3000;\r\n}\r\nexports.requestTimeout = requestTimeout;\r\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}