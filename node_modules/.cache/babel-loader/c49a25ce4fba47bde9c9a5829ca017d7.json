{"ast":null,"code":"/**\r\n * Partial implementation of PKCS#1 v2.2: RSA-OEAP\r\n *\r\n * Modified but based on the following MIT and BSD licensed code:\r\n *\r\n * https://github.com/kjur/jsjws/blob/master/rsa.js:\r\n *\r\n * The 'jsjws'(JSON Web Signature JavaScript Library) License\r\n *\r\n * Copyright (c) 2012 Kenji Urushima\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n * THE SOFTWARE.\r\n *\r\n * http://webrsa.cvs.sourceforge.net/viewvc/webrsa/Client/RSAES-OAEP.js?content-type=text%2Fplain:\r\n *\r\n * RSAES-OAEP.js\r\n * $Id: RSAES-OAEP.js,v 1.1.1.1 2003/03/19 15:37:20 ellispritchard Exp $\r\n * JavaScript Implementation of PKCS #1 v2.1 RSA CRYPTOGRAPHY STANDARD (RSA Laboratories, June 14, 2002)\r\n * Copyright (C) Ellis Pritchard, Guardian Unlimited 2003.\r\n * Contact: ellis@nukinetics.com\r\n * Distributed under the BSD License.\r\n *\r\n * Official documentation: http://www.rsa.com/rsalabs/node.asp?id=2125\r\n *\r\n * @author Evan Jones (http://evanjones.ca/)\r\n * @author Dave Longley\r\n *\r\n * Copyright (c) 2013-2014 Digital Bazaar, Inc.\r\n */\nvar forge = require('./forge');\n\nrequire('./util');\n\nrequire('./random');\n\nrequire('./sha1'); // shortcut for PKCS#1 API\n\n\nvar pkcs1 = module.exports = forge.pkcs1 = forge.pkcs1 || {};\n/**\r\n * Encode the given RSAES-OAEP message (M) using key, with optional label (L)\r\n * and seed.\r\n *\r\n * This method does not perform RSA encryption, it only encodes the message\r\n * using RSAES-OAEP.\r\n *\r\n * @param key the RSA key to use.\r\n * @param message the message to encode.\r\n * @param options the options to use:\r\n *          label an optional label to use.\r\n *          seed the seed to use.\r\n *          md the message digest object to use, undefined for SHA-1.\r\n *          mgf1 optional mgf1 parameters:\r\n *            md the message digest object to use for MGF1.\r\n *\r\n * @return the encoded message bytes.\r\n */\n\npkcs1.encode_rsa_oaep = function (key, message, options) {\n  // parse arguments\n  var label;\n  var seed;\n  var md;\n  var mgf1Md; // legacy args (label, seed, md)\n\n  if (typeof options === 'string') {\n    label = options;\n    seed = arguments[3] || undefined;\n    md = arguments[4] || undefined;\n  } else if (options) {\n    label = options.label || undefined;\n    seed = options.seed || undefined;\n    md = options.md || undefined;\n\n    if (options.mgf1 && options.mgf1.md) {\n      mgf1Md = options.mgf1.md;\n    }\n  } // default OAEP to SHA-1 message digest\n\n\n  if (!md) {\n    md = forge.md.sha1.create();\n  } else {\n    md.start();\n  } // default MGF-1 to same as OAEP\n\n\n  if (!mgf1Md) {\n    mgf1Md = md;\n  } // compute length in bytes and check output\n\n\n  var keyLength = Math.ceil(key.n.bitLength() / 8);\n  var maxLength = keyLength - 2 * md.digestLength - 2;\n\n  if (message.length > maxLength) {\n    var error = new Error('RSAES-OAEP input message length is too long.');\n    error.length = message.length;\n    error.maxLength = maxLength;\n    throw error;\n  }\n\n  if (!label) {\n    label = '';\n  }\n\n  md.update(label, 'raw');\n  var lHash = md.digest();\n  var PS = '';\n  var PS_length = maxLength - message.length;\n\n  for (var i = 0; i < PS_length; i++) {\n    PS += '\\x00';\n  }\n\n  var DB = lHash.getBytes() + PS + '\\x01' + message;\n\n  if (!seed) {\n    seed = forge.random.getBytes(md.digestLength);\n  } else if (seed.length !== md.digestLength) {\n    var error = new Error('Invalid RSAES-OAEP seed. The seed length must ' + 'match the digest length.');\n    error.seedLength = seed.length;\n    error.digestLength = md.digestLength;\n    throw error;\n  }\n\n  var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);\n  var maskedDB = forge.util.xorBytes(DB, dbMask, DB.length);\n  var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);\n  var maskedSeed = forge.util.xorBytes(seed, seedMask, seed.length); // return encoded message\n\n  return '\\x00' + maskedSeed + maskedDB;\n};\n/**\r\n * Decode the given RSAES-OAEP encoded message (EM) using key, with optional\r\n * label (L).\r\n *\r\n * This method does not perform RSA decryption, it only decodes the message\r\n * using RSAES-OAEP.\r\n *\r\n * @param key the RSA key to use.\r\n * @param em the encoded message to decode.\r\n * @param options the options to use:\r\n *          label an optional label to use.\r\n *          md the message digest object to use for OAEP, undefined for SHA-1.\r\n *          mgf1 optional mgf1 parameters:\r\n *            md the message digest object to use for MGF1.\r\n *\r\n * @return the decoded message bytes.\r\n */\n\n\npkcs1.decode_rsa_oaep = function (key, em, options) {\n  // parse args\n  var label;\n  var md;\n  var mgf1Md; // legacy args\n\n  if (typeof options === 'string') {\n    label = options;\n    md = arguments[3] || undefined;\n  } else if (options) {\n    label = options.label || undefined;\n    md = options.md || undefined;\n\n    if (options.mgf1 && options.mgf1.md) {\n      mgf1Md = options.mgf1.md;\n    }\n  } // compute length in bytes\n\n\n  var keyLength = Math.ceil(key.n.bitLength() / 8);\n\n  if (em.length !== keyLength) {\n    var error = new Error('RSAES-OAEP encoded message length is invalid.');\n    error.length = em.length;\n    error.expectedLength = keyLength;\n    throw error;\n  } // default OAEP to SHA-1 message digest\n\n\n  if (md === undefined) {\n    md = forge.md.sha1.create();\n  } else {\n    md.start();\n  } // default MGF-1 to same as OAEP\n\n\n  if (!mgf1Md) {\n    mgf1Md = md;\n  }\n\n  if (keyLength < 2 * md.digestLength + 2) {\n    throw new Error('RSAES-OAEP key is too short for the hash function.');\n  }\n\n  if (!label) {\n    label = '';\n  }\n\n  md.update(label, 'raw');\n  var lHash = md.digest().getBytes(); // split the message into its parts\n\n  var y = em.charAt(0);\n  var maskedSeed = em.substring(1, md.digestLength + 1);\n  var maskedDB = em.substring(1 + md.digestLength);\n  var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);\n  var seed = forge.util.xorBytes(maskedSeed, seedMask, maskedSeed.length);\n  var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);\n  var db = forge.util.xorBytes(maskedDB, dbMask, maskedDB.length);\n  var lHashPrime = db.substring(0, md.digestLength); // constant time check that all values match what is expected\n\n  var error = y !== '\\x00'; // constant time check lHash vs lHashPrime\n\n  for (var i = 0; i < md.digestLength; ++i) {\n    error |= lHash.charAt(i) !== lHashPrime.charAt(i);\n  } // \"constant time\" find the 0x1 byte separating the padding (zeros) from the\n  // message\n  // TODO: It must be possible to do this in a better/smarter way?\n\n\n  var in_ps = 1;\n  var index = md.digestLength;\n\n  for (var j = md.digestLength; j < db.length; j++) {\n    var code = db.charCodeAt(j);\n    var is_0 = code & 0x1 ^ 0x1; // non-zero if not 0 or 1 in the ps section\n\n    var error_mask = in_ps ? 0xfffe : 0x0000;\n    error |= code & error_mask; // latch in_ps to zero after we find 0x1\n\n    in_ps = in_ps & is_0;\n    index += in_ps;\n  }\n\n  if (error || db.charCodeAt(index) !== 0x1) {\n    throw new Error('Invalid RSAES-OAEP padding.');\n  }\n\n  return db.substring(index + 1);\n};\n\nfunction rsa_mgf1(seed, maskLength, hash) {\n  // default to SHA-1 message digest\n  if (!hash) {\n    hash = forge.md.sha1.create();\n  }\n\n  var t = '';\n  var count = Math.ceil(maskLength / hash.digestLength);\n\n  for (var i = 0; i < count; ++i) {\n    var c = String.fromCharCode(i >> 24 & 0xFF, i >> 16 & 0xFF, i >> 8 & 0xFF, i & 0xFF);\n    hash.start();\n    hash.update(seed + c);\n    t += hash.digest().getBytes();\n  }\n\n  return t.substring(0, maskLength);\n}","map":{"version":3,"sources":["C:/Users/ibott/MajorGroupProject/node_modules/node-forge/lib/pkcs1.js"],"names":["forge","require","pkcs1","module","exports","encode_rsa_oaep","key","message","options","label","seed","md","mgf1Md","arguments","undefined","mgf1","sha1","create","start","keyLength","Math","ceil","n","bitLength","maxLength","digestLength","length","error","Error","update","lHash","digest","PS","PS_length","i","DB","getBytes","random","seedLength","dbMask","rsa_mgf1","maskedDB","util","xorBytes","seedMask","maskedSeed","decode_rsa_oaep","em","expectedLength","y","charAt","substring","db","lHashPrime","in_ps","index","j","code","charCodeAt","is_0","error_mask","maskLength","hash","t","count","c","String","fromCharCode"],"mappings":"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","sourcesContent":["/**\r\n * Partial implementation of PKCS#1 v2.2: RSA-OEAP\r\n *\r\n * Modified but based on the following MIT and BSD licensed code:\r\n *\r\n * https://github.com/kjur/jsjws/blob/master/rsa.js:\r\n *\r\n * The 'jsjws'(JSON Web Signature JavaScript Library) License\r\n *\r\n * Copyright (c) 2012 Kenji Urushima\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n * THE SOFTWARE.\r\n *\r\n * http://webrsa.cvs.sourceforge.net/viewvc/webrsa/Client/RSAES-OAEP.js?content-type=text%2Fplain:\r\n *\r\n * RSAES-OAEP.js\r\n * $Id: RSAES-OAEP.js,v 1.1.1.1 2003/03/19 15:37:20 ellispritchard Exp $\r\n * JavaScript Implementation of PKCS #1 v2.1 RSA CRYPTOGRAPHY STANDARD (RSA Laboratories, June 14, 2002)\r\n * Copyright (C) Ellis Pritchard, Guardian Unlimited 2003.\r\n * Contact: ellis@nukinetics.com\r\n * Distributed under the BSD License.\r\n *\r\n * Official documentation: http://www.rsa.com/rsalabs/node.asp?id=2125\r\n *\r\n * @author Evan Jones (http://evanjones.ca/)\r\n * @author Dave Longley\r\n *\r\n * Copyright (c) 2013-2014 Digital Bazaar, Inc.\r\n */\r\nvar forge = require('./forge');\r\nrequire('./util');\r\nrequire('./random');\r\nrequire('./sha1');\r\n\r\n// shortcut for PKCS#1 API\r\nvar pkcs1 = module.exports = forge.pkcs1 = forge.pkcs1 || {};\r\n\r\n/**\r\n * Encode the given RSAES-OAEP message (M) using key, with optional label (L)\r\n * and seed.\r\n *\r\n * This method does not perform RSA encryption, it only encodes the message\r\n * using RSAES-OAEP.\r\n *\r\n * @param key the RSA key to use.\r\n * @param message the message to encode.\r\n * @param options the options to use:\r\n *          label an optional label to use.\r\n *          seed the seed to use.\r\n *          md the message digest object to use, undefined for SHA-1.\r\n *          mgf1 optional mgf1 parameters:\r\n *            md the message digest object to use for MGF1.\r\n *\r\n * @return the encoded message bytes.\r\n */\r\npkcs1.encode_rsa_oaep = function(key, message, options) {\r\n  // parse arguments\r\n  var label;\r\n  var seed;\r\n  var md;\r\n  var mgf1Md;\r\n  // legacy args (label, seed, md)\r\n  if(typeof options === 'string') {\r\n    label = options;\r\n    seed = arguments[3] || undefined;\r\n    md = arguments[4] || undefined;\r\n  } else if(options) {\r\n    label = options.label || undefined;\r\n    seed = options.seed || undefined;\r\n    md = options.md || undefined;\r\n    if(options.mgf1 && options.mgf1.md) {\r\n      mgf1Md = options.mgf1.md;\r\n    }\r\n  }\r\n\r\n  // default OAEP to SHA-1 message digest\r\n  if(!md) {\r\n    md = forge.md.sha1.create();\r\n  } else {\r\n    md.start();\r\n  }\r\n\r\n  // default MGF-1 to same as OAEP\r\n  if(!mgf1Md) {\r\n    mgf1Md = md;\r\n  }\r\n\r\n  // compute length in bytes and check output\r\n  var keyLength = Math.ceil(key.n.bitLength() / 8);\r\n  var maxLength = keyLength - 2 * md.digestLength - 2;\r\n  if(message.length > maxLength) {\r\n    var error = new Error('RSAES-OAEP input message length is too long.');\r\n    error.length = message.length;\r\n    error.maxLength = maxLength;\r\n    throw error;\r\n  }\r\n\r\n  if(!label) {\r\n    label = '';\r\n  }\r\n  md.update(label, 'raw');\r\n  var lHash = md.digest();\r\n\r\n  var PS = '';\r\n  var PS_length = maxLength - message.length;\r\n  for(var i = 0; i < PS_length; i++) {\r\n    PS += '\\x00';\r\n  }\r\n\r\n  var DB = lHash.getBytes() + PS + '\\x01' + message;\r\n\r\n  if(!seed) {\r\n    seed = forge.random.getBytes(md.digestLength);\r\n  } else if(seed.length !== md.digestLength) {\r\n    var error = new Error('Invalid RSAES-OAEP seed. The seed length must ' +\r\n      'match the digest length.');\r\n    error.seedLength = seed.length;\r\n    error.digestLength = md.digestLength;\r\n    throw error;\r\n  }\r\n\r\n  var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);\r\n  var maskedDB = forge.util.xorBytes(DB, dbMask, DB.length);\r\n\r\n  var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);\r\n  var maskedSeed = forge.util.xorBytes(seed, seedMask, seed.length);\r\n\r\n  // return encoded message\r\n  return '\\x00' + maskedSeed + maskedDB;\r\n};\r\n\r\n/**\r\n * Decode the given RSAES-OAEP encoded message (EM) using key, with optional\r\n * label (L).\r\n *\r\n * This method does not perform RSA decryption, it only decodes the message\r\n * using RSAES-OAEP.\r\n *\r\n * @param key the RSA key to use.\r\n * @param em the encoded message to decode.\r\n * @param options the options to use:\r\n *          label an optional label to use.\r\n *          md the message digest object to use for OAEP, undefined for SHA-1.\r\n *          mgf1 optional mgf1 parameters:\r\n *            md the message digest object to use for MGF1.\r\n *\r\n * @return the decoded message bytes.\r\n */\r\npkcs1.decode_rsa_oaep = function(key, em, options) {\r\n  // parse args\r\n  var label;\r\n  var md;\r\n  var mgf1Md;\r\n  // legacy args\r\n  if(typeof options === 'string') {\r\n    label = options;\r\n    md = arguments[3] || undefined;\r\n  } else if(options) {\r\n    label = options.label || undefined;\r\n    md = options.md || undefined;\r\n    if(options.mgf1 && options.mgf1.md) {\r\n      mgf1Md = options.mgf1.md;\r\n    }\r\n  }\r\n\r\n  // compute length in bytes\r\n  var keyLength = Math.ceil(key.n.bitLength() / 8);\r\n\r\n  if(em.length !== keyLength) {\r\n    var error = new Error('RSAES-OAEP encoded message length is invalid.');\r\n    error.length = em.length;\r\n    error.expectedLength = keyLength;\r\n    throw error;\r\n  }\r\n\r\n  // default OAEP to SHA-1 message digest\r\n  if(md === undefined) {\r\n    md = forge.md.sha1.create();\r\n  } else {\r\n    md.start();\r\n  }\r\n\r\n  // default MGF-1 to same as OAEP\r\n  if(!mgf1Md) {\r\n    mgf1Md = md;\r\n  }\r\n\r\n  if(keyLength < 2 * md.digestLength + 2) {\r\n    throw new Error('RSAES-OAEP key is too short for the hash function.');\r\n  }\r\n\r\n  if(!label) {\r\n    label = '';\r\n  }\r\n  md.update(label, 'raw');\r\n  var lHash = md.digest().getBytes();\r\n\r\n  // split the message into its parts\r\n  var y = em.charAt(0);\r\n  var maskedSeed = em.substring(1, md.digestLength + 1);\r\n  var maskedDB = em.substring(1 + md.digestLength);\r\n\r\n  var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);\r\n  var seed = forge.util.xorBytes(maskedSeed, seedMask, maskedSeed.length);\r\n\r\n  var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);\r\n  var db = forge.util.xorBytes(maskedDB, dbMask, maskedDB.length);\r\n\r\n  var lHashPrime = db.substring(0, md.digestLength);\r\n\r\n  // constant time check that all values match what is expected\r\n  var error = (y !== '\\x00');\r\n\r\n  // constant time check lHash vs lHashPrime\r\n  for(var i = 0; i < md.digestLength; ++i) {\r\n    error |= (lHash.charAt(i) !== lHashPrime.charAt(i));\r\n  }\r\n\r\n  // \"constant time\" find the 0x1 byte separating the padding (zeros) from the\r\n  // message\r\n  // TODO: It must be possible to do this in a better/smarter way?\r\n  var in_ps = 1;\r\n  var index = md.digestLength;\r\n  for(var j = md.digestLength; j < db.length; j++) {\r\n    var code = db.charCodeAt(j);\r\n\r\n    var is_0 = (code & 0x1) ^ 0x1;\r\n\r\n    // non-zero if not 0 or 1 in the ps section\r\n    var error_mask = in_ps ? 0xfffe : 0x0000;\r\n    error |= (code & error_mask);\r\n\r\n    // latch in_ps to zero after we find 0x1\r\n    in_ps = in_ps & is_0;\r\n    index += in_ps;\r\n  }\r\n\r\n  if(error || db.charCodeAt(index) !== 0x1) {\r\n    throw new Error('Invalid RSAES-OAEP padding.');\r\n  }\r\n\r\n  return db.substring(index + 1);\r\n};\r\n\r\nfunction rsa_mgf1(seed, maskLength, hash) {\r\n  // default to SHA-1 message digest\r\n  if(!hash) {\r\n    hash = forge.md.sha1.create();\r\n  }\r\n  var t = '';\r\n  var count = Math.ceil(maskLength / hash.digestLength);\r\n  for(var i = 0; i < count; ++i) {\r\n    var c = String.fromCharCode(\r\n      (i >> 24) & 0xFF, (i >> 16) & 0xFF, (i >> 8) & 0xFF, i & 0xFF);\r\n    hash.start();\r\n    hash.update(seed + c);\r\n    t += hash.digest().getBytes();\r\n  }\r\n  return t.substring(0, maskLength);\r\n}\r\n"]},"metadata":{},"sourceType":"script"}