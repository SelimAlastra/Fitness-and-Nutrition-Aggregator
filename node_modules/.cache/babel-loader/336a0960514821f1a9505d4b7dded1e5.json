{"ast":null,"code":"\"use strict\"; // Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AwsClient = void 0;\n\nconst awsrequestsigner_1 = require(\"./awsrequestsigner\");\n\nconst baseexternalclient_1 = require(\"./baseexternalclient\");\n/**\r\n * AWS external account client. This is used for AWS workloads, where\r\n * AWS STS GetCallerIdentity serialized signed requests are exchanged for\r\n * GCP access token.\r\n */\n\n\nclass AwsClient extends baseexternalclient_1.BaseExternalAccountClient {\n  /**\r\n   * Instantiates an AwsClient instance using the provided JSON\r\n   * object loaded from an external account credentials file.\r\n   * An error is thrown if the credential is not a valid AWS credential.\r\n   * @param options The external account options object typically loaded\r\n   *   from the external account JSON credential file.\r\n   * @param additionalOptions Optional additional behavior customization\r\n   *   options. These currently customize expiration threshold time and\r\n   *   whether to retry on 401/403 API request errors.\r\n   */\n  constructor(options, additionalOptions) {\n    var _a;\n\n    super(options, additionalOptions);\n    this.environmentId = options.credential_source.environment_id; // This is only required if the AWS region is not available in the\n    // AWS_REGION environment variable\n\n    this.regionUrl = options.credential_source.region_url; // This is only required if AWS security credentials are not available in\n    // environment variables.\n\n    this.securityCredentialsUrl = options.credential_source.url;\n    this.regionalCredVerificationUrl = options.credential_source.regional_cred_verification_url;\n    const match = (_a = this.environmentId) === null || _a === void 0 ? void 0 : _a.match(/^(aws)(\\d+)$/);\n\n    if (!match || !this.regionalCredVerificationUrl) {\n      throw new Error('No valid AWS \"credential_source\" provided');\n    } else if (parseInt(match[2], 10) !== 1) {\n      throw new Error(`aws version \"${match[2]}\" is not supported in the current build.`);\n    }\n\n    this.awsRequestSigner = null;\n    this.region = '';\n  }\n  /**\r\n   * Triggered when an external subject token is needed to be exchanged for a\r\n   * GCP access token via GCP STS endpoint.\r\n   * This uses the `options.credential_source` object to figure out how\r\n   * to retrieve the token using the current environment. In this case,\r\n   * this uses a serialized AWS signed request to the STS GetCallerIdentity\r\n   * endpoint.\r\n   * The logic is summarized as:\r\n   * 1. Retrieve AWS region from availability-zone.\r\n   * 2a. Check AWS credentials in environment variables. If not found, get\r\n   *     from security-credentials endpoint.\r\n   * 2b. Get AWS credentials from security-credentials endpoint. In order\r\n   *     to retrieve this, the AWS role needs to be determined by calling\r\n   *     security-credentials endpoint without any argument. Then the\r\n   *     credentials can be retrieved via: security-credentials/role_name\r\n   * 3. Generate the signed request to AWS STS GetCallerIdentity action.\r\n   * 4. Inject x-goog-cloud-target-resource into header and serialize the\r\n   *    signed request. This will be the subject-token to pass to GCP STS.\r\n   * @return A promise that resolves with the external subject token.\r\n   */\n\n\n  async retrieveSubjectToken() {\n    // Initialize AWS request signer if not already initialized.\n    if (!this.awsRequestSigner) {\n      this.region = await this.getAwsRegion();\n      this.awsRequestSigner = new awsrequestsigner_1.AwsRequestSigner(async () => {\n        // Check environment variables for permanent credentials first.\n        // https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html\n        if (process.env['AWS_ACCESS_KEY_ID'] && process.env['AWS_SECRET_ACCESS_KEY']) {\n          return {\n            accessKeyId: process.env['AWS_ACCESS_KEY_ID'],\n            secretAccessKey: process.env['AWS_SECRET_ACCESS_KEY'],\n            // This is normally not available for permanent credentials.\n            token: process.env['AWS_SESSION_TOKEN']\n          };\n        } // Since the role on a VM can change, we don't need to cache it.\n\n\n        const roleName = await this.getAwsRoleName(); // Temporary credentials typically last for several hours.\n        // Expiration is returned in response.\n        // Consider future optimization of this logic to cache AWS tokens\n        // until their natural expiration.\n\n        const awsCreds = await this.getAwsSecurityCredentials(roleName);\n        return {\n          accessKeyId: awsCreds.AccessKeyId,\n          secretAccessKey: awsCreds.SecretAccessKey,\n          token: awsCreds.Token\n        };\n      }, this.region);\n    } // Generate signed request to AWS STS GetCallerIdentity API.\n    // Use the required regional endpoint. Otherwise, the request will fail.\n\n\n    const options = await this.awsRequestSigner.getRequestOptions({\n      url: this.regionalCredVerificationUrl.replace('{region}', this.region),\n      method: 'POST'\n    }); // The GCP STS endpoint expects the headers to be formatted as:\n    // [\n    //   {key: 'x-amz-date', value: '...'},\n    //   {key: 'Authorization', value: '...'},\n    //   ...\n    // ]\n    // And then serialized as:\n    // encodeURIComponent(JSON.stringify({\n    //   url: '...',\n    //   method: 'POST',\n    //   headers: [{key: 'x-amz-date', value: '...'}, ...]\n    // }))\n\n    const reformattedHeader = [];\n    const extendedHeaders = Object.assign({\n      // The full, canonical resource name of the workload identity pool\n      // provider, with or without the HTTPS prefix.\n      // Including this header as part of the signature is recommended to\n      // ensure data integrity.\n      'x-goog-cloud-target-resource': this.audience\n    }, options.headers); // Reformat header to GCP STS expected format.\n\n    for (const key in extendedHeaders) {\n      reformattedHeader.push({\n        key,\n        value: extendedHeaders[key]\n      });\n    } // Serialize the reformatted signed request.\n\n\n    return encodeURIComponent(JSON.stringify({\n      url: options.url,\n      method: options.method,\n      headers: reformattedHeader\n    }));\n  }\n  /**\r\n   * @return A promise that resolves with the current AWS region.\r\n   */\n\n\n  async getAwsRegion() {\n    if (process.env['AWS_REGION']) {\n      return process.env['AWS_REGION'];\n    }\n\n    if (!this.regionUrl) {\n      throw new Error('Unable to determine AWS region due to missing ' + '\"options.credential_source.region_url\"');\n    }\n\n    const opts = {\n      url: this.regionUrl,\n      method: 'GET',\n      responseType: 'text'\n    };\n    const response = await this.transporter.request(opts); // Remove last character. For example, if us-east-2b is returned,\n    // the region would be us-east-2.\n\n    return response.data.substr(0, response.data.length - 1);\n  }\n  /**\r\n   * @return A promise that resolves with the assigned role to the current\r\n   *   AWS VM. This is needed for calling the security-credentials endpoint.\r\n   */\n\n\n  async getAwsRoleName() {\n    if (!this.securityCredentialsUrl) {\n      throw new Error('Unable to determine AWS role name due to missing ' + '\"options.credential_source.url\"');\n    }\n\n    const opts = {\n      url: this.securityCredentialsUrl,\n      method: 'GET',\n      responseType: 'text'\n    };\n    const response = await this.transporter.request(opts);\n    return response.data;\n  }\n  /**\r\n   * Retrieves the temporary AWS credentials by calling the security-credentials\r\n   * endpoint as specified in the `credential_source` object.\r\n   * @param roleName The role attached to the current VM.\r\n   * @return A promise that resolves with the temporary AWS credentials\r\n   *   needed for creating the GetCallerIdentity signed request.\r\n   */\n\n\n  async getAwsSecurityCredentials(roleName) {\n    const response = await this.transporter.request({\n      url: `${this.securityCredentialsUrl}/${roleName}`,\n      responseType: 'json'\n    });\n    return response.data;\n  }\n\n}\n\nexports.AwsClient = AwsClient;","map":{"version":3,"sources":["C:/Users/ibott/MajorGroupProject/node_modules/google-auth-library/build/src/auth/awsclient.js"],"names":["Object","defineProperty","exports","value","AwsClient","awsrequestsigner_1","require","baseexternalclient_1","BaseExternalAccountClient","constructor","options","additionalOptions","_a","environmentId","credential_source","environment_id","regionUrl","region_url","securityCredentialsUrl","url","regionalCredVerificationUrl","regional_cred_verification_url","match","Error","parseInt","awsRequestSigner","region","retrieveSubjectToken","getAwsRegion","AwsRequestSigner","process","env","accessKeyId","secretAccessKey","token","roleName","getAwsRoleName","awsCreds","getAwsSecurityCredentials","AccessKeyId","SecretAccessKey","Token","getRequestOptions","replace","method","reformattedHeader","extendedHeaders","assign","audience","headers","key","push","encodeURIComponent","JSON","stringify","opts","responseType","response","transporter","request","data","substr","length"],"mappings":"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","sourcesContent":["\"use strict\";\r\n// Copyright 2021 Google LLC\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.AwsClient = void 0;\r\nconst awsrequestsigner_1 = require(\"./awsrequestsigner\");\r\nconst baseexternalclient_1 = require(\"./baseexternalclient\");\r\n/**\r\n * AWS external account client. This is used for AWS workloads, where\r\n * AWS STS GetCallerIdentity serialized signed requests are exchanged for\r\n * GCP access token.\r\n */\r\nclass AwsClient extends baseexternalclient_1.BaseExternalAccountClient {\r\n    /**\r\n     * Instantiates an AwsClient instance using the provided JSON\r\n     * object loaded from an external account credentials file.\r\n     * An error is thrown if the credential is not a valid AWS credential.\r\n     * @param options The external account options object typically loaded\r\n     *   from the external account JSON credential file.\r\n     * @param additionalOptions Optional additional behavior customization\r\n     *   options. These currently customize expiration threshold time and\r\n     *   whether to retry on 401/403 API request errors.\r\n     */\r\n    constructor(options, additionalOptions) {\r\n        var _a;\r\n        super(options, additionalOptions);\r\n        this.environmentId = options.credential_source.environment_id;\r\n        // This is only required if the AWS region is not available in the\r\n        // AWS_REGION environment variable\r\n        this.regionUrl = options.credential_source.region_url;\r\n        // This is only required if AWS security credentials are not available in\r\n        // environment variables.\r\n        this.securityCredentialsUrl = options.credential_source.url;\r\n        this.regionalCredVerificationUrl =\r\n            options.credential_source.regional_cred_verification_url;\r\n        const match = (_a = this.environmentId) === null || _a === void 0 ? void 0 : _a.match(/^(aws)(\\d+)$/);\r\n        if (!match || !this.regionalCredVerificationUrl) {\r\n            throw new Error('No valid AWS \"credential_source\" provided');\r\n        }\r\n        else if (parseInt(match[2], 10) !== 1) {\r\n            throw new Error(`aws version \"${match[2]}\" is not supported in the current build.`);\r\n        }\r\n        this.awsRequestSigner = null;\r\n        this.region = '';\r\n    }\r\n    /**\r\n     * Triggered when an external subject token is needed to be exchanged for a\r\n     * GCP access token via GCP STS endpoint.\r\n     * This uses the `options.credential_source` object to figure out how\r\n     * to retrieve the token using the current environment. In this case,\r\n     * this uses a serialized AWS signed request to the STS GetCallerIdentity\r\n     * endpoint.\r\n     * The logic is summarized as:\r\n     * 1. Retrieve AWS region from availability-zone.\r\n     * 2a. Check AWS credentials in environment variables. If not found, get\r\n     *     from security-credentials endpoint.\r\n     * 2b. Get AWS credentials from security-credentials endpoint. In order\r\n     *     to retrieve this, the AWS role needs to be determined by calling\r\n     *     security-credentials endpoint without any argument. Then the\r\n     *     credentials can be retrieved via: security-credentials/role_name\r\n     * 3. Generate the signed request to AWS STS GetCallerIdentity action.\r\n     * 4. Inject x-goog-cloud-target-resource into header and serialize the\r\n     *    signed request. This will be the subject-token to pass to GCP STS.\r\n     * @return A promise that resolves with the external subject token.\r\n     */\r\n    async retrieveSubjectToken() {\r\n        // Initialize AWS request signer if not already initialized.\r\n        if (!this.awsRequestSigner) {\r\n            this.region = await this.getAwsRegion();\r\n            this.awsRequestSigner = new awsrequestsigner_1.AwsRequestSigner(async () => {\r\n                // Check environment variables for permanent credentials first.\r\n                // https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html\r\n                if (process.env['AWS_ACCESS_KEY_ID'] &&\r\n                    process.env['AWS_SECRET_ACCESS_KEY']) {\r\n                    return {\r\n                        accessKeyId: process.env['AWS_ACCESS_KEY_ID'],\r\n                        secretAccessKey: process.env['AWS_SECRET_ACCESS_KEY'],\r\n                        // This is normally not available for permanent credentials.\r\n                        token: process.env['AWS_SESSION_TOKEN'],\r\n                    };\r\n                }\r\n                // Since the role on a VM can change, we don't need to cache it.\r\n                const roleName = await this.getAwsRoleName();\r\n                // Temporary credentials typically last for several hours.\r\n                // Expiration is returned in response.\r\n                // Consider future optimization of this logic to cache AWS tokens\r\n                // until their natural expiration.\r\n                const awsCreds = await this.getAwsSecurityCredentials(roleName);\r\n                return {\r\n                    accessKeyId: awsCreds.AccessKeyId,\r\n                    secretAccessKey: awsCreds.SecretAccessKey,\r\n                    token: awsCreds.Token,\r\n                };\r\n            }, this.region);\r\n        }\r\n        // Generate signed request to AWS STS GetCallerIdentity API.\r\n        // Use the required regional endpoint. Otherwise, the request will fail.\r\n        const options = await this.awsRequestSigner.getRequestOptions({\r\n            url: this.regionalCredVerificationUrl.replace('{region}', this.region),\r\n            method: 'POST',\r\n        });\r\n        // The GCP STS endpoint expects the headers to be formatted as:\r\n        // [\r\n        //   {key: 'x-amz-date', value: '...'},\r\n        //   {key: 'Authorization', value: '...'},\r\n        //   ...\r\n        // ]\r\n        // And then serialized as:\r\n        // encodeURIComponent(JSON.stringify({\r\n        //   url: '...',\r\n        //   method: 'POST',\r\n        //   headers: [{key: 'x-amz-date', value: '...'}, ...]\r\n        // }))\r\n        const reformattedHeader = [];\r\n        const extendedHeaders = Object.assign({\r\n            // The full, canonical resource name of the workload identity pool\r\n            // provider, with or without the HTTPS prefix.\r\n            // Including this header as part of the signature is recommended to\r\n            // ensure data integrity.\r\n            'x-goog-cloud-target-resource': this.audience,\r\n        }, options.headers);\r\n        // Reformat header to GCP STS expected format.\r\n        for (const key in extendedHeaders) {\r\n            reformattedHeader.push({\r\n                key,\r\n                value: extendedHeaders[key],\r\n            });\r\n        }\r\n        // Serialize the reformatted signed request.\r\n        return encodeURIComponent(JSON.stringify({\r\n            url: options.url,\r\n            method: options.method,\r\n            headers: reformattedHeader,\r\n        }));\r\n    }\r\n    /**\r\n     * @return A promise that resolves with the current AWS region.\r\n     */\r\n    async getAwsRegion() {\r\n        if (process.env['AWS_REGION']) {\r\n            return process.env['AWS_REGION'];\r\n        }\r\n        if (!this.regionUrl) {\r\n            throw new Error('Unable to determine AWS region due to missing ' +\r\n                '\"options.credential_source.region_url\"');\r\n        }\r\n        const opts = {\r\n            url: this.regionUrl,\r\n            method: 'GET',\r\n            responseType: 'text',\r\n        };\r\n        const response = await this.transporter.request(opts);\r\n        // Remove last character. For example, if us-east-2b is returned,\r\n        // the region would be us-east-2.\r\n        return response.data.substr(0, response.data.length - 1);\r\n    }\r\n    /**\r\n     * @return A promise that resolves with the assigned role to the current\r\n     *   AWS VM. This is needed for calling the security-credentials endpoint.\r\n     */\r\n    async getAwsRoleName() {\r\n        if (!this.securityCredentialsUrl) {\r\n            throw new Error('Unable to determine AWS role name due to missing ' +\r\n                '\"options.credential_source.url\"');\r\n        }\r\n        const opts = {\r\n            url: this.securityCredentialsUrl,\r\n            method: 'GET',\r\n            responseType: 'text',\r\n        };\r\n        const response = await this.transporter.request(opts);\r\n        return response.data;\r\n    }\r\n    /**\r\n     * Retrieves the temporary AWS credentials by calling the security-credentials\r\n     * endpoint as specified in the `credential_source` object.\r\n     * @param roleName The role attached to the current VM.\r\n     * @return A promise that resolves with the temporary AWS credentials\r\n     *   needed for creating the GetCallerIdentity signed request.\r\n     */\r\n    async getAwsSecurityCredentials(roleName) {\r\n        const response = await this.transporter.request({\r\n            url: `${this.securityCredentialsUrl}/${roleName}`,\r\n            responseType: 'json',\r\n        });\r\n        return response.data;\r\n    }\r\n}\r\nexports.AwsClient = AwsClient;\r\n//# sourceMappingURL=awsclient.js.map"]},"metadata":{},"sourceType":"script"}