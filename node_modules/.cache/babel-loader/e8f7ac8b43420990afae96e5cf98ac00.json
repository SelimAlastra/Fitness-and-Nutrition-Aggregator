{"ast":null,"code":"/**\r\n * Javascript implementation of PKCS#1 PSS signature padding.\r\n *\r\n * @author Stefan Siegl\r\n *\r\n * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>\r\n */\nvar forge = require('./forge');\n\nrequire('./random');\n\nrequire('./util'); // shortcut for PSS API\n\n\nvar pss = module.exports = forge.pss = forge.pss || {};\n/**\r\n * Creates a PSS signature scheme object.\r\n *\r\n * There are several ways to provide a salt for encoding:\r\n *\r\n * 1. Specify the saltLength only and the built-in PRNG will generate it.\r\n * 2. Specify the saltLength and a custom PRNG with 'getBytesSync' defined that\r\n *   will be used.\r\n * 3. Specify the salt itself as a forge.util.ByteBuffer.\r\n *\r\n * @param options the options to use:\r\n *          md the message digest object to use, a forge md instance.\r\n *          mgf the mask generation function to use, a forge mgf instance.\r\n *          [saltLength] the length of the salt in octets.\r\n *          [prng] the pseudo-random number generator to use to produce a salt.\r\n *          [salt] the salt to use when encoding.\r\n *\r\n * @return a signature scheme object.\r\n */\n\npss.create = function (options) {\n  // backwards compatibility w/legacy args: hash, mgf, sLen\n  if (arguments.length === 3) {\n    options = {\n      md: arguments[0],\n      mgf: arguments[1],\n      saltLength: arguments[2]\n    };\n  }\n\n  var hash = options.md;\n  var mgf = options.mgf;\n  var hLen = hash.digestLength;\n  var salt_ = options.salt || null;\n\n  if (typeof salt_ === 'string') {\n    // assume binary-encoded string\n    salt_ = forge.util.createBuffer(salt_);\n  }\n\n  var sLen;\n\n  if ('saltLength' in options) {\n    sLen = options.saltLength;\n  } else if (salt_ !== null) {\n    sLen = salt_.length();\n  } else {\n    throw new Error('Salt length not specified or specific salt not given.');\n  }\n\n  if (salt_ !== null && salt_.length() !== sLen) {\n    throw new Error('Given salt length does not match length of given salt.');\n  }\n\n  var prng = options.prng || forge.random;\n  var pssobj = {};\n  /**\r\n   * Encodes a PSS signature.\r\n   *\r\n   * This function implements EMSA-PSS-ENCODE as per RFC 3447, section 9.1.1.\r\n   *\r\n   * @param md the message digest object with the hash to sign.\r\n   * @param modsBits the length of the RSA modulus in bits.\r\n   *\r\n   * @return the encoded message as a binary-encoded string of length\r\n   *           ceil((modBits - 1) / 8).\r\n   */\n\n  pssobj.encode = function (md, modBits) {\n    var i;\n    var emBits = modBits - 1;\n    var emLen = Math.ceil(emBits / 8);\n    /* 2. Let mHash = Hash(M), an octet string of length hLen. */\n\n    var mHash = md.digest().getBytes();\n    /* 3. If emLen < hLen + sLen + 2, output \"encoding error\" and stop. */\n\n    if (emLen < hLen + sLen + 2) {\n      throw new Error('Message is too long to encrypt.');\n    }\n    /* 4. Generate a random octet string salt of length sLen; if sLen = 0,\r\n     *    then salt is the empty string. */\n\n\n    var salt;\n\n    if (salt_ === null) {\n      salt = prng.getBytesSync(sLen);\n    } else {\n      salt = salt_.bytes();\n    }\n    /* 5. Let M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt; */\n\n\n    var m_ = new forge.util.ByteBuffer();\n    m_.fillWithByte(0, 8);\n    m_.putBytes(mHash);\n    m_.putBytes(salt);\n    /* 6. Let H = Hash(M'), an octet string of length hLen. */\n\n    hash.start();\n    hash.update(m_.getBytes());\n    var h = hash.digest().getBytes();\n    /* 7. Generate an octet string PS consisting of emLen - sLen - hLen - 2\r\n     *    zero octets.  The length of PS may be 0. */\n\n    var ps = new forge.util.ByteBuffer();\n    ps.fillWithByte(0, emLen - sLen - hLen - 2);\n    /* 8. Let DB = PS || 0x01 || salt; DB is an octet string of length\r\n     *    emLen - hLen - 1. */\n\n    ps.putByte(0x01);\n    ps.putBytes(salt);\n    var db = ps.getBytes();\n    /* 9. Let dbMask = MGF(H, emLen - hLen - 1). */\n\n    var maskLen = emLen - hLen - 1;\n    var dbMask = mgf.generate(h, maskLen);\n    /* 10. Let maskedDB = DB \\xor dbMask. */\n\n    var maskedDB = '';\n\n    for (i = 0; i < maskLen; i++) {\n      maskedDB += String.fromCharCode(db.charCodeAt(i) ^ dbMask.charCodeAt(i));\n    }\n    /* 11. Set the leftmost 8emLen - emBits bits of the leftmost octet in\r\n     *     maskedDB to zero. */\n\n\n    var mask = 0xFF00 >> 8 * emLen - emBits & 0xFF;\n    maskedDB = String.fromCharCode(maskedDB.charCodeAt(0) & ~mask) + maskedDB.substr(1);\n    /* 12. Let EM = maskedDB || H || 0xbc.\r\n     * 13. Output EM. */\n\n    return maskedDB + h + String.fromCharCode(0xbc);\n  };\n  /**\r\n   * Verifies a PSS signature.\r\n   *\r\n   * This function implements EMSA-PSS-VERIFY as per RFC 3447, section 9.1.2.\r\n   *\r\n   * @param mHash the message digest hash, as a binary-encoded string, to\r\n   *         compare against the signature.\r\n   * @param em the encoded message, as a binary-encoded string\r\n   *          (RSA decryption result).\r\n   * @param modsBits the length of the RSA modulus in bits.\r\n   *\r\n   * @return true if the signature was verified, false if not.\r\n   */\n\n\n  pssobj.verify = function (mHash, em, modBits) {\n    var i;\n    var emBits = modBits - 1;\n    var emLen = Math.ceil(emBits / 8);\n    /* c. Convert the message representative m to an encoded message EM\r\n     *    of length emLen = ceil((modBits - 1) / 8) octets, where modBits\r\n     *    is the length in bits of the RSA modulus n */\n\n    em = em.substr(-emLen);\n    /* 3. If emLen < hLen + sLen + 2, output \"inconsistent\" and stop. */\n\n    if (emLen < hLen + sLen + 2) {\n      throw new Error('Inconsistent parameters to PSS signature verification.');\n    }\n    /* 4. If the rightmost octet of EM does not have hexadecimal value\r\n     *    0xbc, output \"inconsistent\" and stop. */\n\n\n    if (em.charCodeAt(emLen - 1) !== 0xbc) {\n      throw new Error('Encoded message does not end in 0xBC.');\n    }\n    /* 5. Let maskedDB be the leftmost emLen - hLen - 1 octets of EM, and\r\n     *    let H be the next hLen octets. */\n\n\n    var maskLen = emLen - hLen - 1;\n    var maskedDB = em.substr(0, maskLen);\n    var h = em.substr(maskLen, hLen);\n    /* 6. If the leftmost 8emLen - emBits bits of the leftmost octet in\r\n     *    maskedDB are not all equal to zero, output \"inconsistent\" and stop. */\n\n    var mask = 0xFF00 >> 8 * emLen - emBits & 0xFF;\n\n    if ((maskedDB.charCodeAt(0) & mask) !== 0) {\n      throw new Error('Bits beyond keysize not zero as expected.');\n    }\n    /* 7. Let dbMask = MGF(H, emLen - hLen - 1). */\n\n\n    var dbMask = mgf.generate(h, maskLen);\n    /* 8. Let DB = maskedDB \\xor dbMask. */\n\n    var db = '';\n\n    for (i = 0; i < maskLen; i++) {\n      db += String.fromCharCode(maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i));\n    }\n    /* 9. Set the leftmost 8emLen - emBits bits of the leftmost octet\r\n     * in DB to zero. */\n\n\n    db = String.fromCharCode(db.charCodeAt(0) & ~mask) + db.substr(1);\n    /* 10. If the emLen - hLen - sLen - 2 leftmost octets of DB are not zero\r\n     * or if the octet at position emLen - hLen - sLen - 1 (the leftmost\r\n     * position is \"position 1\") does not have hexadecimal value 0x01,\r\n     * output \"inconsistent\" and stop. */\n\n    var checkLen = emLen - hLen - sLen - 2;\n\n    for (i = 0; i < checkLen; i++) {\n      if (db.charCodeAt(i) !== 0x00) {\n        throw new Error('Leftmost octets not zero as expected');\n      }\n    }\n\n    if (db.charCodeAt(checkLen) !== 0x01) {\n      throw new Error('Inconsistent PSS signature, 0x01 marker not found');\n    }\n    /* 11. Let salt be the last sLen octets of DB. */\n\n\n    var salt = db.substr(-sLen);\n    /* 12.  Let M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt */\n\n    var m_ = new forge.util.ByteBuffer();\n    m_.fillWithByte(0, 8);\n    m_.putBytes(mHash);\n    m_.putBytes(salt);\n    /* 13. Let H' = Hash(M'), an octet string of length hLen. */\n\n    hash.start();\n    hash.update(m_.getBytes());\n    var h_ = hash.digest().getBytes();\n    /* 14. If H = H', output \"consistent.\" Otherwise, output \"inconsistent.\" */\n\n    return h === h_;\n  };\n\n  return pssobj;\n};","map":{"version":3,"sources":["C:/Users/ibott/MajorGroupProject/node_modules/node-forge/lib/pss.js"],"names":["forge","require","pss","module","exports","create","options","arguments","length","md","mgf","saltLength","hash","hLen","digestLength","salt_","salt","util","createBuffer","sLen","Error","prng","random","pssobj","encode","modBits","i","emBits","emLen","Math","ceil","mHash","digest","getBytes","getBytesSync","bytes","m_","ByteBuffer","fillWithByte","putBytes","start","update","h","ps","putByte","db","maskLen","dbMask","generate","maskedDB","String","fromCharCode","charCodeAt","mask","substr","verify","em","checkLen","h_"],"mappings":"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","sourcesContent":["/**\r\n * Javascript implementation of PKCS#1 PSS signature padding.\r\n *\r\n * @author Stefan Siegl\r\n *\r\n * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>\r\n */\r\nvar forge = require('./forge');\r\nrequire('./random');\r\nrequire('./util');\r\n\r\n// shortcut for PSS API\r\nvar pss = module.exports = forge.pss = forge.pss || {};\r\n\r\n/**\r\n * Creates a PSS signature scheme object.\r\n *\r\n * There are several ways to provide a salt for encoding:\r\n *\r\n * 1. Specify the saltLength only and the built-in PRNG will generate it.\r\n * 2. Specify the saltLength and a custom PRNG with 'getBytesSync' defined that\r\n *   will be used.\r\n * 3. Specify the salt itself as a forge.util.ByteBuffer.\r\n *\r\n * @param options the options to use:\r\n *          md the message digest object to use, a forge md instance.\r\n *          mgf the mask generation function to use, a forge mgf instance.\r\n *          [saltLength] the length of the salt in octets.\r\n *          [prng] the pseudo-random number generator to use to produce a salt.\r\n *          [salt] the salt to use when encoding.\r\n *\r\n * @return a signature scheme object.\r\n */\r\npss.create = function(options) {\r\n  // backwards compatibility w/legacy args: hash, mgf, sLen\r\n  if(arguments.length === 3) {\r\n    options = {\r\n      md: arguments[0],\r\n      mgf: arguments[1],\r\n      saltLength: arguments[2]\r\n    };\r\n  }\r\n\r\n  var hash = options.md;\r\n  var mgf = options.mgf;\r\n  var hLen = hash.digestLength;\r\n\r\n  var salt_ = options.salt || null;\r\n  if(typeof salt_ === 'string') {\r\n    // assume binary-encoded string\r\n    salt_ = forge.util.createBuffer(salt_);\r\n  }\r\n\r\n  var sLen;\r\n  if('saltLength' in options) {\r\n    sLen = options.saltLength;\r\n  } else if(salt_ !== null) {\r\n    sLen = salt_.length();\r\n  } else {\r\n    throw new Error('Salt length not specified or specific salt not given.');\r\n  }\r\n\r\n  if(salt_ !== null && salt_.length() !== sLen) {\r\n    throw new Error('Given salt length does not match length of given salt.');\r\n  }\r\n\r\n  var prng = options.prng || forge.random;\r\n\r\n  var pssobj = {};\r\n\r\n  /**\r\n   * Encodes a PSS signature.\r\n   *\r\n   * This function implements EMSA-PSS-ENCODE as per RFC 3447, section 9.1.1.\r\n   *\r\n   * @param md the message digest object with the hash to sign.\r\n   * @param modsBits the length of the RSA modulus in bits.\r\n   *\r\n   * @return the encoded message as a binary-encoded string of length\r\n   *           ceil((modBits - 1) / 8).\r\n   */\r\n  pssobj.encode = function(md, modBits) {\r\n    var i;\r\n    var emBits = modBits - 1;\r\n    var emLen = Math.ceil(emBits / 8);\r\n\r\n    /* 2. Let mHash = Hash(M), an octet string of length hLen. */\r\n    var mHash = md.digest().getBytes();\r\n\r\n    /* 3. If emLen < hLen + sLen + 2, output \"encoding error\" and stop. */\r\n    if(emLen < hLen + sLen + 2) {\r\n      throw new Error('Message is too long to encrypt.');\r\n    }\r\n\r\n    /* 4. Generate a random octet string salt of length sLen; if sLen = 0,\r\n     *    then salt is the empty string. */\r\n    var salt;\r\n    if(salt_ === null) {\r\n      salt = prng.getBytesSync(sLen);\r\n    } else {\r\n      salt = salt_.bytes();\r\n    }\r\n\r\n    /* 5. Let M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt; */\r\n    var m_ = new forge.util.ByteBuffer();\r\n    m_.fillWithByte(0, 8);\r\n    m_.putBytes(mHash);\r\n    m_.putBytes(salt);\r\n\r\n    /* 6. Let H = Hash(M'), an octet string of length hLen. */\r\n    hash.start();\r\n    hash.update(m_.getBytes());\r\n    var h = hash.digest().getBytes();\r\n\r\n    /* 7. Generate an octet string PS consisting of emLen - sLen - hLen - 2\r\n     *    zero octets.  The length of PS may be 0. */\r\n    var ps = new forge.util.ByteBuffer();\r\n    ps.fillWithByte(0, emLen - sLen - hLen - 2);\r\n\r\n    /* 8. Let DB = PS || 0x01 || salt; DB is an octet string of length\r\n     *    emLen - hLen - 1. */\r\n    ps.putByte(0x01);\r\n    ps.putBytes(salt);\r\n    var db = ps.getBytes();\r\n\r\n    /* 9. Let dbMask = MGF(H, emLen - hLen - 1). */\r\n    var maskLen = emLen - hLen - 1;\r\n    var dbMask = mgf.generate(h, maskLen);\r\n\r\n    /* 10. Let maskedDB = DB \\xor dbMask. */\r\n    var maskedDB = '';\r\n    for(i = 0; i < maskLen; i++) {\r\n      maskedDB += String.fromCharCode(db.charCodeAt(i) ^ dbMask.charCodeAt(i));\r\n    }\r\n\r\n    /* 11. Set the leftmost 8emLen - emBits bits of the leftmost octet in\r\n     *     maskedDB to zero. */\r\n    var mask = (0xFF00 >> (8 * emLen - emBits)) & 0xFF;\r\n    maskedDB = String.fromCharCode(maskedDB.charCodeAt(0) & ~mask) +\r\n      maskedDB.substr(1);\r\n\r\n    /* 12. Let EM = maskedDB || H || 0xbc.\r\n     * 13. Output EM. */\r\n    return maskedDB + h + String.fromCharCode(0xbc);\r\n  };\r\n\r\n  /**\r\n   * Verifies a PSS signature.\r\n   *\r\n   * This function implements EMSA-PSS-VERIFY as per RFC 3447, section 9.1.2.\r\n   *\r\n   * @param mHash the message digest hash, as a binary-encoded string, to\r\n   *         compare against the signature.\r\n   * @param em the encoded message, as a binary-encoded string\r\n   *          (RSA decryption result).\r\n   * @param modsBits the length of the RSA modulus in bits.\r\n   *\r\n   * @return true if the signature was verified, false if not.\r\n   */\r\n  pssobj.verify = function(mHash, em, modBits) {\r\n    var i;\r\n    var emBits = modBits - 1;\r\n    var emLen = Math.ceil(emBits / 8);\r\n\r\n    /* c. Convert the message representative m to an encoded message EM\r\n     *    of length emLen = ceil((modBits - 1) / 8) octets, where modBits\r\n     *    is the length in bits of the RSA modulus n */\r\n    em = em.substr(-emLen);\r\n\r\n    /* 3. If emLen < hLen + sLen + 2, output \"inconsistent\" and stop. */\r\n    if(emLen < hLen + sLen + 2) {\r\n      throw new Error('Inconsistent parameters to PSS signature verification.');\r\n    }\r\n\r\n    /* 4. If the rightmost octet of EM does not have hexadecimal value\r\n     *    0xbc, output \"inconsistent\" and stop. */\r\n    if(em.charCodeAt(emLen - 1) !== 0xbc) {\r\n      throw new Error('Encoded message does not end in 0xBC.');\r\n    }\r\n\r\n    /* 5. Let maskedDB be the leftmost emLen - hLen - 1 octets of EM, and\r\n     *    let H be the next hLen octets. */\r\n    var maskLen = emLen - hLen - 1;\r\n    var maskedDB = em.substr(0, maskLen);\r\n    var h = em.substr(maskLen, hLen);\r\n\r\n    /* 6. If the leftmost 8emLen - emBits bits of the leftmost octet in\r\n     *    maskedDB are not all equal to zero, output \"inconsistent\" and stop. */\r\n    var mask = (0xFF00 >> (8 * emLen - emBits)) & 0xFF;\r\n    if((maskedDB.charCodeAt(0) & mask) !== 0) {\r\n      throw new Error('Bits beyond keysize not zero as expected.');\r\n    }\r\n\r\n    /* 7. Let dbMask = MGF(H, emLen - hLen - 1). */\r\n    var dbMask = mgf.generate(h, maskLen);\r\n\r\n    /* 8. Let DB = maskedDB \\xor dbMask. */\r\n    var db = '';\r\n    for(i = 0; i < maskLen; i++) {\r\n      db += String.fromCharCode(maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i));\r\n    }\r\n\r\n    /* 9. Set the leftmost 8emLen - emBits bits of the leftmost octet\r\n     * in DB to zero. */\r\n    db = String.fromCharCode(db.charCodeAt(0) & ~mask) + db.substr(1);\r\n\r\n    /* 10. If the emLen - hLen - sLen - 2 leftmost octets of DB are not zero\r\n     * or if the octet at position emLen - hLen - sLen - 1 (the leftmost\r\n     * position is \"position 1\") does not have hexadecimal value 0x01,\r\n     * output \"inconsistent\" and stop. */\r\n    var checkLen = emLen - hLen - sLen - 2;\r\n    for(i = 0; i < checkLen; i++) {\r\n      if(db.charCodeAt(i) !== 0x00) {\r\n        throw new Error('Leftmost octets not zero as expected');\r\n      }\r\n    }\r\n\r\n    if(db.charCodeAt(checkLen) !== 0x01) {\r\n      throw new Error('Inconsistent PSS signature, 0x01 marker not found');\r\n    }\r\n\r\n    /* 11. Let salt be the last sLen octets of DB. */\r\n    var salt = db.substr(-sLen);\r\n\r\n    /* 12.  Let M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt */\r\n    var m_ = new forge.util.ByteBuffer();\r\n    m_.fillWithByte(0, 8);\r\n    m_.putBytes(mHash);\r\n    m_.putBytes(salt);\r\n\r\n    /* 13. Let H' = Hash(M'), an octet string of length hLen. */\r\n    hash.start();\r\n    hash.update(m_.getBytes());\r\n    var h_ = hash.digest().getBytes();\r\n\r\n    /* 14. If H = H', output \"consistent.\" Otherwise, output \"inconsistent.\" */\r\n    return h === h_;\r\n  };\r\n\r\n  return pssobj;\r\n};\r\n"]},"metadata":{},"sourceType":"script"}