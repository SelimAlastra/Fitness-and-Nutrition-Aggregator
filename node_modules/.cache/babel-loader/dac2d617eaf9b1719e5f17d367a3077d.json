{"ast":null,"code":"/**\r\n * Javascript implementation of RSA-KEM.\r\n *\r\n * @author Lautaro Cozzani Rodriguez\r\n * @author Dave Longley\r\n *\r\n * Copyright (c) 2014 Lautaro Cozzani <lautaro.cozzani@scytl.com>\r\n * Copyright (c) 2014 Digital Bazaar, Inc.\r\n */\nvar forge = require('./forge');\n\nrequire('./util');\n\nrequire('./random');\n\nrequire('./jsbn');\n\nmodule.exports = forge.kem = forge.kem || {};\nvar BigInteger = forge.jsbn.BigInteger;\n/**\r\n * The API for the RSA Key Encapsulation Mechanism (RSA-KEM) from ISO 18033-2.\r\n */\n\nforge.kem.rsa = {};\n/**\r\n * Creates an RSA KEM API object for generating a secret asymmetric key.\r\n *\r\n * The symmetric key may be generated via a call to 'encrypt', which will\r\n * produce a ciphertext to be transmitted to the recipient and a key to be\r\n * kept secret. The ciphertext is a parameter to be passed to 'decrypt' which\r\n * will produce the same secret key for the recipient to use to decrypt a\r\n * message that was encrypted with the secret key.\r\n *\r\n * @param kdf the KDF API to use (eg: new forge.kem.kdf1()).\r\n * @param options the options to use.\r\n *          [prng] a custom crypto-secure pseudo-random number generator to use,\r\n *            that must define \"getBytesSync\".\r\n */\n\nforge.kem.rsa.create = function (kdf, options) {\n  options = options || {};\n  var prng = options.prng || forge.random;\n  var kem = {};\n  /**\r\n   * Generates a secret key and its encapsulation.\r\n   *\r\n   * @param publicKey the RSA public key to encrypt with.\r\n   * @param keyLength the length, in bytes, of the secret key to generate.\r\n   *\r\n   * @return an object with:\r\n   *   encapsulation: the ciphertext for generating the secret key, as a\r\n   *     binary-encoded string of bytes.\r\n   *   key: the secret key to use for encrypting a message.\r\n   */\n\n  kem.encrypt = function (publicKey, keyLength) {\n    // generate a random r where 1 < r < n\n    var byteLength = Math.ceil(publicKey.n.bitLength() / 8);\n    var r;\n\n    do {\n      r = new BigInteger(forge.util.bytesToHex(prng.getBytesSync(byteLength)), 16).mod(publicKey.n);\n    } while (r.compareTo(BigInteger.ONE) <= 0); // prepend r with zeros\n\n\n    r = forge.util.hexToBytes(r.toString(16));\n    var zeros = byteLength - r.length;\n\n    if (zeros > 0) {\n      r = forge.util.fillString(String.fromCharCode(0), zeros) + r;\n    } // encrypt the random\n\n\n    var encapsulation = publicKey.encrypt(r, 'NONE'); // generate the secret key\n\n    var key = kdf.generate(r, keyLength);\n    return {\n      encapsulation: encapsulation,\n      key: key\n    };\n  };\n  /**\r\n   * Decrypts an encapsulated secret key.\r\n   *\r\n   * @param privateKey the RSA private key to decrypt with.\r\n   * @param encapsulation the ciphertext for generating the secret key, as\r\n   *          a binary-encoded string of bytes.\r\n   * @param keyLength the length, in bytes, of the secret key to generate.\r\n   *\r\n   * @return the secret key as a binary-encoded string of bytes.\r\n   */\n\n\n  kem.decrypt = function (privateKey, encapsulation, keyLength) {\n    // decrypt the encapsulation and generate the secret key\n    var r = privateKey.decrypt(encapsulation, 'NONE');\n    return kdf.generate(r, keyLength);\n  };\n\n  return kem;\n}; // TODO: add forge.kem.kdf.create('KDF1', {md: ..., ...}) API?\n\n/**\r\n * Creates a key derivation API object that implements KDF1 per ISO 18033-2.\r\n *\r\n * @param md the hash API to use.\r\n * @param [digestLength] an optional digest length that must be positive and\r\n *          less than or equal to md.digestLength.\r\n *\r\n * @return a KDF1 API object.\r\n */\n\n\nforge.kem.kdf1 = function (md, digestLength) {\n  _createKDF(this, md, 0, digestLength || md.digestLength);\n};\n/**\r\n * Creates a key derivation API object that implements KDF2 per ISO 18033-2.\r\n *\r\n * @param md the hash API to use.\r\n * @param [digestLength] an optional digest length that must be positive and\r\n *          less than or equal to md.digestLength.\r\n *\r\n * @return a KDF2 API object.\r\n */\n\n\nforge.kem.kdf2 = function (md, digestLength) {\n  _createKDF(this, md, 1, digestLength || md.digestLength);\n};\n/**\r\n * Creates a KDF1 or KDF2 API object.\r\n *\r\n * @param md the hash API to use.\r\n * @param counterStart the starting index for the counter.\r\n * @param digestLength the digest length to use.\r\n *\r\n * @return the KDF API object.\r\n */\n\n\nfunction _createKDF(kdf, md, counterStart, digestLength) {\n  /**\r\n   * Generate a key of the specified length.\r\n   *\r\n   * @param x the binary-encoded byte string to generate a key from.\r\n   * @param length the number of bytes to generate (the size of the key).\r\n   *\r\n   * @return the key as a binary-encoded string.\r\n   */\n  kdf.generate = function (x, length) {\n    var key = new forge.util.ByteBuffer(); // run counter from counterStart to ceil(length / Hash.len)\n\n    var k = Math.ceil(length / digestLength) + counterStart;\n    var c = new forge.util.ByteBuffer();\n\n    for (var i = counterStart; i < k; ++i) {\n      // I2OSP(i, 4): convert counter to an octet string of 4 octets\n      c.putInt32(i); // digest 'x' and the counter and add the result to the key\n\n      md.start();\n      md.update(x + c.getBytes());\n      var hash = md.digest();\n      key.putBytes(hash.getBytes(digestLength));\n    } // truncate to the correct key length\n\n\n    key.truncate(key.length() - length);\n    return key.getBytes();\n  };\n}","map":{"version":3,"sources":["C:/Users/ibott/MajorGroupProject/node_modules/node-forge/lib/kem.js"],"names":["forge","require","module","exports","kem","BigInteger","jsbn","rsa","create","kdf","options","prng","random","encrypt","publicKey","keyLength","byteLength","Math","ceil","n","bitLength","r","util","bytesToHex","getBytesSync","mod","compareTo","ONE","hexToBytes","toString","zeros","length","fillString","String","fromCharCode","encapsulation","key","generate","decrypt","privateKey","kdf1","md","digestLength","_createKDF","kdf2","counterStart","x","ByteBuffer","k","c","i","putInt32","start","update","getBytes","hash","digest","putBytes","truncate"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIA,KAAK,GAAGC,OAAO,CAAC,SAAD,CAAnB;;AACAA,OAAO,CAAC,QAAD,CAAP;;AACAA,OAAO,CAAC,UAAD,CAAP;;AACAA,OAAO,CAAC,QAAD,CAAP;;AAEAC,MAAM,CAACC,OAAP,GAAiBH,KAAK,CAACI,GAAN,GAAYJ,KAAK,CAACI,GAAN,IAAa,EAA1C;AAEA,IAAIC,UAAU,GAAGL,KAAK,CAACM,IAAN,CAAWD,UAA5B;AAEA;AACA;AACA;;AACAL,KAAK,CAACI,GAAN,CAAUG,GAAV,GAAgB,EAAhB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAP,KAAK,CAACI,GAAN,CAAUG,GAAV,CAAcC,MAAd,GAAuB,UAASC,GAAT,EAAcC,OAAd,EAAuB;AAC5CA,EAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AACA,MAAIC,IAAI,GAAGD,OAAO,CAACC,IAAR,IAAgBX,KAAK,CAACY,MAAjC;AAEA,MAAIR,GAAG,GAAG,EAAV;AAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACEA,EAAAA,GAAG,CAACS,OAAJ,GAAc,UAASC,SAAT,EAAoBC,SAApB,EAA+B;AAC3C;AACA,QAAIC,UAAU,GAAGC,IAAI,CAACC,IAAL,CAAUJ,SAAS,CAACK,CAAV,CAAYC,SAAZ,KAA0B,CAApC,CAAjB;AACA,QAAIC,CAAJ;;AACA,OAAG;AACDA,MAAAA,CAAC,GAAG,IAAIhB,UAAJ,CACFL,KAAK,CAACsB,IAAN,CAAWC,UAAX,CAAsBZ,IAAI,CAACa,YAAL,CAAkBR,UAAlB,CAAtB,CADE,EAEF,EAFE,EAEES,GAFF,CAEMX,SAAS,CAACK,CAFhB,CAAJ;AAGD,KAJD,QAIQE,CAAC,CAACK,SAAF,CAAYrB,UAAU,CAACsB,GAAvB,KAA+B,CAJvC,EAJ2C,CAU3C;;;AACAN,IAAAA,CAAC,GAAGrB,KAAK,CAACsB,IAAN,CAAWM,UAAX,CAAsBP,CAAC,CAACQ,QAAF,CAAW,EAAX,CAAtB,CAAJ;AACA,QAAIC,KAAK,GAAGd,UAAU,GAAGK,CAAC,CAACU,MAA3B;;AACA,QAAGD,KAAK,GAAG,CAAX,EAAc;AACZT,MAAAA,CAAC,GAAGrB,KAAK,CAACsB,IAAN,CAAWU,UAAX,CAAsBC,MAAM,CAACC,YAAP,CAAoB,CAApB,CAAtB,EAA8CJ,KAA9C,IAAuDT,CAA3D;AACD,KAf0C,CAiB3C;;;AACA,QAAIc,aAAa,GAAGrB,SAAS,CAACD,OAAV,CAAkBQ,CAAlB,EAAqB,MAArB,CAApB,CAlB2C,CAoB3C;;AACA,QAAIe,GAAG,GAAG3B,GAAG,CAAC4B,QAAJ,CAAahB,CAAb,EAAgBN,SAAhB,CAAV;AAEA,WAAO;AAACoB,MAAAA,aAAa,EAAEA,aAAhB;AAA+BC,MAAAA,GAAG,EAAEA;AAApC,KAAP;AACD,GAxBD;AA0BA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEhC,EAAAA,GAAG,CAACkC,OAAJ,GAAc,UAASC,UAAT,EAAqBJ,aAArB,EAAoCpB,SAApC,EAA+C;AAC3D;AACA,QAAIM,CAAC,GAAGkB,UAAU,CAACD,OAAX,CAAmBH,aAAnB,EAAkC,MAAlC,CAAR;AACA,WAAO1B,GAAG,CAAC4B,QAAJ,CAAahB,CAAb,EAAgBN,SAAhB,CAAP;AACD,GAJD;;AAMA,SAAOX,GAAP;AACD,CA5DD,C,CA8DA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAJ,KAAK,CAACI,GAAN,CAAUoC,IAAV,GAAiB,UAASC,EAAT,EAAaC,YAAb,EAA2B;AAC1CC,EAAAA,UAAU,CAAC,IAAD,EAAOF,EAAP,EAAW,CAAX,EAAcC,YAAY,IAAID,EAAE,CAACC,YAAjC,CAAV;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA1C,KAAK,CAACI,GAAN,CAAUwC,IAAV,GAAiB,UAASH,EAAT,EAAaC,YAAb,EAA2B;AAC1CC,EAAAA,UAAU,CAAC,IAAD,EAAOF,EAAP,EAAW,CAAX,EAAcC,YAAY,IAAID,EAAE,CAACC,YAAjC,CAAV;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,UAAT,CAAoBlC,GAApB,EAAyBgC,EAAzB,EAA6BI,YAA7B,EAA2CH,YAA3C,EAAyD;AACvD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACEjC,EAAAA,GAAG,CAAC4B,QAAJ,GAAe,UAASS,CAAT,EAAYf,MAAZ,EAAoB;AACjC,QAAIK,GAAG,GAAG,IAAIpC,KAAK,CAACsB,IAAN,CAAWyB,UAAf,EAAV,CADiC,CAGjC;;AACA,QAAIC,CAAC,GAAG/B,IAAI,CAACC,IAAL,CAAUa,MAAM,GAAGW,YAAnB,IAAmCG,YAA3C;AAEA,QAAII,CAAC,GAAG,IAAIjD,KAAK,CAACsB,IAAN,CAAWyB,UAAf,EAAR;;AACA,SAAI,IAAIG,CAAC,GAAGL,YAAZ,EAA0BK,CAAC,GAAGF,CAA9B,EAAiC,EAAEE,CAAnC,EAAsC;AACpC;AACAD,MAAAA,CAAC,CAACE,QAAF,CAAWD,CAAX,EAFoC,CAIpC;;AACAT,MAAAA,EAAE,CAACW,KAAH;AACAX,MAAAA,EAAE,CAACY,MAAH,CAAUP,CAAC,GAAGG,CAAC,CAACK,QAAF,EAAd;AACA,UAAIC,IAAI,GAAGd,EAAE,CAACe,MAAH,EAAX;AACApB,MAAAA,GAAG,CAACqB,QAAJ,CAAaF,IAAI,CAACD,QAAL,CAAcZ,YAAd,CAAb;AACD,KAhBgC,CAkBjC;;;AACAN,IAAAA,GAAG,CAACsB,QAAJ,CAAatB,GAAG,CAACL,MAAJ,KAAeA,MAA5B;AACA,WAAOK,GAAG,CAACkB,QAAJ,EAAP;AACD,GArBD;AAsBD","sourcesContent":["/**\r\n * Javascript implementation of RSA-KEM.\r\n *\r\n * @author Lautaro Cozzani Rodriguez\r\n * @author Dave Longley\r\n *\r\n * Copyright (c) 2014 Lautaro Cozzani <lautaro.cozzani@scytl.com>\r\n * Copyright (c) 2014 Digital Bazaar, Inc.\r\n */\r\nvar forge = require('./forge');\r\nrequire('./util');\r\nrequire('./random');\r\nrequire('./jsbn');\r\n\r\nmodule.exports = forge.kem = forge.kem || {};\r\n\r\nvar BigInteger = forge.jsbn.BigInteger;\r\n\r\n/**\r\n * The API for the RSA Key Encapsulation Mechanism (RSA-KEM) from ISO 18033-2.\r\n */\r\nforge.kem.rsa = {};\r\n\r\n/**\r\n * Creates an RSA KEM API object for generating a secret asymmetric key.\r\n *\r\n * The symmetric key may be generated via a call to 'encrypt', which will\r\n * produce a ciphertext to be transmitted to the recipient and a key to be\r\n * kept secret. The ciphertext is a parameter to be passed to 'decrypt' which\r\n * will produce the same secret key for the recipient to use to decrypt a\r\n * message that was encrypted with the secret key.\r\n *\r\n * @param kdf the KDF API to use (eg: new forge.kem.kdf1()).\r\n * @param options the options to use.\r\n *          [prng] a custom crypto-secure pseudo-random number generator to use,\r\n *            that must define \"getBytesSync\".\r\n */\r\nforge.kem.rsa.create = function(kdf, options) {\r\n  options = options || {};\r\n  var prng = options.prng || forge.random;\r\n\r\n  var kem = {};\r\n\r\n  /**\r\n   * Generates a secret key and its encapsulation.\r\n   *\r\n   * @param publicKey the RSA public key to encrypt with.\r\n   * @param keyLength the length, in bytes, of the secret key to generate.\r\n   *\r\n   * @return an object with:\r\n   *   encapsulation: the ciphertext for generating the secret key, as a\r\n   *     binary-encoded string of bytes.\r\n   *   key: the secret key to use for encrypting a message.\r\n   */\r\n  kem.encrypt = function(publicKey, keyLength) {\r\n    // generate a random r where 1 < r < n\r\n    var byteLength = Math.ceil(publicKey.n.bitLength() / 8);\r\n    var r;\r\n    do {\r\n      r = new BigInteger(\r\n        forge.util.bytesToHex(prng.getBytesSync(byteLength)),\r\n        16).mod(publicKey.n);\r\n    } while(r.compareTo(BigInteger.ONE) <= 0);\r\n\r\n    // prepend r with zeros\r\n    r = forge.util.hexToBytes(r.toString(16));\r\n    var zeros = byteLength - r.length;\r\n    if(zeros > 0) {\r\n      r = forge.util.fillString(String.fromCharCode(0), zeros) + r;\r\n    }\r\n\r\n    // encrypt the random\r\n    var encapsulation = publicKey.encrypt(r, 'NONE');\r\n\r\n    // generate the secret key\r\n    var key = kdf.generate(r, keyLength);\r\n\r\n    return {encapsulation: encapsulation, key: key};\r\n  };\r\n\r\n  /**\r\n   * Decrypts an encapsulated secret key.\r\n   *\r\n   * @param privateKey the RSA private key to decrypt with.\r\n   * @param encapsulation the ciphertext for generating the secret key, as\r\n   *          a binary-encoded string of bytes.\r\n   * @param keyLength the length, in bytes, of the secret key to generate.\r\n   *\r\n   * @return the secret key as a binary-encoded string of bytes.\r\n   */\r\n  kem.decrypt = function(privateKey, encapsulation, keyLength) {\r\n    // decrypt the encapsulation and generate the secret key\r\n    var r = privateKey.decrypt(encapsulation, 'NONE');\r\n    return kdf.generate(r, keyLength);\r\n  };\r\n\r\n  return kem;\r\n};\r\n\r\n// TODO: add forge.kem.kdf.create('KDF1', {md: ..., ...}) API?\r\n\r\n/**\r\n * Creates a key derivation API object that implements KDF1 per ISO 18033-2.\r\n *\r\n * @param md the hash API to use.\r\n * @param [digestLength] an optional digest length that must be positive and\r\n *          less than or equal to md.digestLength.\r\n *\r\n * @return a KDF1 API object.\r\n */\r\nforge.kem.kdf1 = function(md, digestLength) {\r\n  _createKDF(this, md, 0, digestLength || md.digestLength);\r\n};\r\n\r\n/**\r\n * Creates a key derivation API object that implements KDF2 per ISO 18033-2.\r\n *\r\n * @param md the hash API to use.\r\n * @param [digestLength] an optional digest length that must be positive and\r\n *          less than or equal to md.digestLength.\r\n *\r\n * @return a KDF2 API object.\r\n */\r\nforge.kem.kdf2 = function(md, digestLength) {\r\n  _createKDF(this, md, 1, digestLength || md.digestLength);\r\n};\r\n\r\n/**\r\n * Creates a KDF1 or KDF2 API object.\r\n *\r\n * @param md the hash API to use.\r\n * @param counterStart the starting index for the counter.\r\n * @param digestLength the digest length to use.\r\n *\r\n * @return the KDF API object.\r\n */\r\nfunction _createKDF(kdf, md, counterStart, digestLength) {\r\n  /**\r\n   * Generate a key of the specified length.\r\n   *\r\n   * @param x the binary-encoded byte string to generate a key from.\r\n   * @param length the number of bytes to generate (the size of the key).\r\n   *\r\n   * @return the key as a binary-encoded string.\r\n   */\r\n  kdf.generate = function(x, length) {\r\n    var key = new forge.util.ByteBuffer();\r\n\r\n    // run counter from counterStart to ceil(length / Hash.len)\r\n    var k = Math.ceil(length / digestLength) + counterStart;\r\n\r\n    var c = new forge.util.ByteBuffer();\r\n    for(var i = counterStart; i < k; ++i) {\r\n      // I2OSP(i, 4): convert counter to an octet string of 4 octets\r\n      c.putInt32(i);\r\n\r\n      // digest 'x' and the counter and add the result to the key\r\n      md.start();\r\n      md.update(x + c.getBytes());\r\n      var hash = md.digest();\r\n      key.putBytes(hash.getBytes(digestLength));\r\n    }\r\n\r\n    // truncate to the correct key length\r\n    key.truncate(key.length() - length);\r\n    return key.getBytes();\r\n  };\r\n}\r\n"]},"metadata":{},"sourceType":"script"}