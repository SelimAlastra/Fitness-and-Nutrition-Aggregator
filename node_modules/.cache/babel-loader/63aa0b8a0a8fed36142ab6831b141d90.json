{"ast":null,"code":"\"use strict\"; // Copyright 2018 Google LLC\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getRetryConfig = void 0;\n\nasync function getRetryConfig(err) {\n  var _a;\n\n  let config = getConfig(err);\n\n  if (!err || !err.config || !config && !err.config.retry) {\n    return {\n      shouldRetry: false\n    };\n  }\n\n  config = config || {};\n  config.currentRetryAttempt = config.currentRetryAttempt || 0;\n  config.retry = config.retry === undefined || config.retry === null ? 3 : config.retry;\n  config.httpMethodsToRetry = config.httpMethodsToRetry || ['GET', 'HEAD', 'PUT', 'OPTIONS', 'DELETE'];\n  config.noResponseRetries = config.noResponseRetries === undefined || config.noResponseRetries === null ? 2 : config.noResponseRetries; // If this wasn't in the list of status codes where we want\n  // to automatically retry, return.\n\n  const retryRanges = [// https://en.wikipedia.org/wiki/List_of_HTTP_status_codes\n  // 1xx - Retry (Informational, request still processing)\n  // 2xx - Do not retry (Success)\n  // 3xx - Do not retry (Redirect)\n  // 4xx - Do not retry (Client errors)\n  // 429 - Retry (\"Too Many Requests\")\n  // 5xx - Retry (Server errors)\n  [100, 199], [429, 429], [500, 599]];\n  config.statusCodesToRetry = config.statusCodesToRetry || retryRanges; // Put the config back into the err\n\n  err.config.retryConfig = config; // Determine if we should retry the request\n\n  const shouldRetryFn = config.shouldRetry || shouldRetryRequest;\n\n  if (!(await shouldRetryFn(err))) {\n    return {\n      shouldRetry: false,\n      config: err.config\n    };\n  } // Calculate time to wait with exponential backoff.\n  // If this is the first retry, look for a configured retryDelay.\n\n\n  const retryDelay = config.currentRetryAttempt ? 0 : (_a = config.retryDelay) !== null && _a !== void 0 ? _a : 100; // Formula: retryDelay + ((2^c - 1 / 2) * 1000)\n\n  const delay = retryDelay + (Math.pow(2, config.currentRetryAttempt) - 1) / 2 * 1000; // We're going to retry!  Incremenent the counter.\n\n  err.config.retryConfig.currentRetryAttempt += 1; // Create a promise that invokes the retry after the backOffDelay\n\n  const backoff = new Promise(resolve => {\n    setTimeout(resolve, delay);\n  }); // Notify the user if they added an `onRetryAttempt` handler\n\n  if (config.onRetryAttempt) {\n    config.onRetryAttempt(err);\n  } // Return the promise in which recalls Gaxios to retry the request\n\n\n  await backoff;\n  return {\n    shouldRetry: true,\n    config: err.config\n  };\n}\n\nexports.getRetryConfig = getRetryConfig;\n/**\r\n * Determine based on config if we should retry the request.\r\n * @param err The GaxiosError passed to the interceptor.\r\n */\n\nfunction shouldRetryRequest(err) {\n  const config = getConfig(err); // node-fetch raises an AbortError if signaled:\n  // https://github.com/bitinn/node-fetch#request-cancellation-with-abortsignal\n\n  if (err.name === 'AbortError') {\n    return false;\n  } // If there's no config, or retries are disabled, return.\n\n\n  if (!config || config.retry === 0) {\n    return false;\n  } // Check if this error has no response (ETIMEDOUT, ENOTFOUND, etc)\n\n\n  if (!err.response && (config.currentRetryAttempt || 0) >= config.noResponseRetries) {\n    return false;\n  } // Only retry with configured HttpMethods.\n\n\n  if (!err.config.method || config.httpMethodsToRetry.indexOf(err.config.method.toUpperCase()) < 0) {\n    return false;\n  } // If this wasn't in the list of status codes where we want\n  // to automatically retry, return.\n\n\n  if (err.response && err.response.status) {\n    let isInRange = false;\n\n    for (const [min, max] of config.statusCodesToRetry) {\n      const status = err.response.status;\n\n      if (status >= min && status <= max) {\n        isInRange = true;\n        break;\n      }\n    }\n\n    if (!isInRange) {\n      return false;\n    }\n  } // If we are out of retry attempts, return\n\n\n  config.currentRetryAttempt = config.currentRetryAttempt || 0;\n\n  if (config.currentRetryAttempt >= config.retry) {\n    return false;\n  }\n\n  return true;\n}\n/**\r\n * Acquire the raxConfig object from an GaxiosError if available.\r\n * @param err The Gaxios error with a config object.\r\n */\n\n\nfunction getConfig(err) {\n  if (err && err.config && err.config.retryConfig) {\n    return err.config.retryConfig;\n  }\n\n  return;\n}","map":{"version":3,"sources":["../../src/retry.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\n// Copyright 2018 Google LLC\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//    http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.getRetryConfig = void 0;\r\nasync function getRetryConfig(err) {\r\n    var _a;\r\n    let config = getConfig(err);\r\n    if (!err || !err.config || (!config && !err.config.retry)) {\r\n        return { shouldRetry: false };\r\n    }\r\n    config = config || {};\r\n    config.currentRetryAttempt = config.currentRetryAttempt || 0;\r\n    config.retry =\r\n        config.retry === undefined || config.retry === null ? 3 : config.retry;\r\n    config.httpMethodsToRetry = config.httpMethodsToRetry || [\r\n        'GET',\r\n        'HEAD',\r\n        'PUT',\r\n        'OPTIONS',\r\n        'DELETE',\r\n    ];\r\n    config.noResponseRetries =\r\n        config.noResponseRetries === undefined || config.noResponseRetries === null\r\n            ? 2\r\n            : config.noResponseRetries;\r\n    // If this wasn't in the list of status codes where we want\r\n    // to automatically retry, return.\r\n    const retryRanges = [\r\n        // https://en.wikipedia.org/wiki/List_of_HTTP_status_codes\r\n        // 1xx - Retry (Informational, request still processing)\r\n        // 2xx - Do not retry (Success)\r\n        // 3xx - Do not retry (Redirect)\r\n        // 4xx - Do not retry (Client errors)\r\n        // 429 - Retry (\"Too Many Requests\")\r\n        // 5xx - Retry (Server errors)\r\n        [100, 199],\r\n        [429, 429],\r\n        [500, 599],\r\n    ];\r\n    config.statusCodesToRetry = config.statusCodesToRetry || retryRanges;\r\n    // Put the config back into the err\r\n    err.config.retryConfig = config;\r\n    // Determine if we should retry the request\r\n    const shouldRetryFn = config.shouldRetry || shouldRetryRequest;\r\n    if (!(await shouldRetryFn(err))) {\r\n        return { shouldRetry: false, config: err.config };\r\n    }\r\n    // Calculate time to wait with exponential backoff.\r\n    // If this is the first retry, look for a configured retryDelay.\r\n    const retryDelay = config.currentRetryAttempt ? 0 : (_a = config.retryDelay) !== null && _a !== void 0 ? _a : 100;\r\n    // Formula: retryDelay + ((2^c - 1 / 2) * 1000)\r\n    const delay = retryDelay + ((Math.pow(2, config.currentRetryAttempt) - 1) / 2) * 1000;\r\n    // We're going to retry!  Incremenent the counter.\r\n    err.config.retryConfig.currentRetryAttempt += 1;\r\n    // Create a promise that invokes the retry after the backOffDelay\r\n    const backoff = new Promise(resolve => {\r\n        setTimeout(resolve, delay);\r\n    });\r\n    // Notify the user if they added an `onRetryAttempt` handler\r\n    if (config.onRetryAttempt) {\r\n        config.onRetryAttempt(err);\r\n    }\r\n    // Return the promise in which recalls Gaxios to retry the request\r\n    await backoff;\r\n    return { shouldRetry: true, config: err.config };\r\n}\r\nexports.getRetryConfig = getRetryConfig;\r\n/**\r\n * Determine based on config if we should retry the request.\r\n * @param err The GaxiosError passed to the interceptor.\r\n */\r\nfunction shouldRetryRequest(err) {\r\n    const config = getConfig(err);\r\n    // node-fetch raises an AbortError if signaled:\r\n    // https://github.com/bitinn/node-fetch#request-cancellation-with-abortsignal\r\n    if (err.name === 'AbortError') {\r\n        return false;\r\n    }\r\n    // If there's no config, or retries are disabled, return.\r\n    if (!config || config.retry === 0) {\r\n        return false;\r\n    }\r\n    // Check if this error has no response (ETIMEDOUT, ENOTFOUND, etc)\r\n    if (!err.response &&\r\n        (config.currentRetryAttempt || 0) >= config.noResponseRetries) {\r\n        return false;\r\n    }\r\n    // Only retry with configured HttpMethods.\r\n    if (!err.config.method ||\r\n        config.httpMethodsToRetry.indexOf(err.config.method.toUpperCase()) < 0) {\r\n        return false;\r\n    }\r\n    // If this wasn't in the list of status codes where we want\r\n    // to automatically retry, return.\r\n    if (err.response && err.response.status) {\r\n        let isInRange = false;\r\n        for (const [min, max] of config.statusCodesToRetry) {\r\n            const status = err.response.status;\r\n            if (status >= min && status <= max) {\r\n                isInRange = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!isInRange) {\r\n            return false;\r\n        }\r\n    }\r\n    // If we are out of retry attempts, return\r\n    config.currentRetryAttempt = config.currentRetryAttempt || 0;\r\n    if (config.currentRetryAttempt >= config.retry) {\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Acquire the raxConfig object from an GaxiosError if available.\r\n * @param err The Gaxios error with a config object.\r\n */\r\nfunction getConfig(err) {\r\n    if (err && err.config && err.config.retryConfig) {\r\n        return err.config.retryConfig;\r\n    }\r\n    return;\r\n}\r\n//# sourceMappingURL=retry.js.map"]},"metadata":{},"sourceType":"script"}