{"ast":null,"code":"/**\r\n * Javascript implementation of PKCS#12.\r\n *\r\n * @author Dave Longley\r\n * @author Stefan Siegl <stesie@brokenpipe.de>\r\n *\r\n * Copyright (c) 2010-2014 Digital Bazaar, Inc.\r\n * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>\r\n *\r\n * The ASN.1 representation of PKCS#12 is as follows\r\n * (see ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-12/pkcs-12-tc1.pdf for details)\r\n *\r\n * PFX ::= SEQUENCE {\r\n *   version  INTEGER {v3(3)}(v3,...),\r\n *   authSafe ContentInfo,\r\n *   macData  MacData OPTIONAL\r\n * }\r\n *\r\n * MacData ::= SEQUENCE {\r\n *   mac DigestInfo,\r\n *   macSalt OCTET STRING,\r\n *   iterations INTEGER DEFAULT 1\r\n * }\r\n * Note: The iterations default is for historical reasons and its use is\r\n * deprecated. A higher value, like 1024, is recommended.\r\n *\r\n * DigestInfo is defined in PKCS#7 as follows:\r\n *\r\n * DigestInfo ::= SEQUENCE {\r\n *   digestAlgorithm DigestAlgorithmIdentifier,\r\n *   digest Digest\r\n * }\r\n *\r\n * DigestAlgorithmIdentifier ::= AlgorithmIdentifier\r\n *\r\n * The AlgorithmIdentifier contains an Object Identifier (OID) and parameters\r\n * for the algorithm, if any. In the case of SHA1 there is none.\r\n *\r\n * AlgorithmIdentifer ::= SEQUENCE {\r\n *    algorithm OBJECT IDENTIFIER,\r\n *    parameters ANY DEFINED BY algorithm OPTIONAL\r\n * }\r\n *\r\n * Digest ::= OCTET STRING\r\n *\r\n *\r\n * ContentInfo ::= SEQUENCE {\r\n *   contentType ContentType,\r\n *   content     [0] EXPLICIT ANY DEFINED BY contentType OPTIONAL\r\n * }\r\n *\r\n * ContentType ::= OBJECT IDENTIFIER\r\n *\r\n * AuthenticatedSafe ::= SEQUENCE OF ContentInfo\r\n * -- Data if unencrypted\r\n * -- EncryptedData if password-encrypted\r\n * -- EnvelopedData if public key-encrypted\r\n *\r\n *\r\n * SafeContents ::= SEQUENCE OF SafeBag\r\n *\r\n * SafeBag ::= SEQUENCE {\r\n *   bagId     BAG-TYPE.&id ({PKCS12BagSet})\r\n *   bagValue  [0] EXPLICIT BAG-TYPE.&Type({PKCS12BagSet}{@bagId}),\r\n *   bagAttributes SET OF PKCS12Attribute OPTIONAL\r\n * }\r\n *\r\n * PKCS12Attribute ::= SEQUENCE {\r\n *   attrId ATTRIBUTE.&id ({PKCS12AttrSet}),\r\n *   attrValues SET OF ATTRIBUTE.&Type ({PKCS12AttrSet}{@attrId})\r\n * } -- This type is compatible with the X.500 type 'Attribute'\r\n *\r\n * PKCS12AttrSet ATTRIBUTE ::= {\r\n *   friendlyName | -- from PKCS #9\r\n *   localKeyId, -- from PKCS #9\r\n *   ... -- Other attributes are allowed\r\n * }\r\n *\r\n * CertBag ::= SEQUENCE {\r\n *   certId    BAG-TYPE.&id   ({CertTypes}),\r\n *   certValue [0] EXPLICIT BAG-TYPE.&Type ({CertTypes}{@certId})\r\n * }\r\n *\r\n * x509Certificate BAG-TYPE ::= {OCTET STRING IDENTIFIED BY {certTypes 1}}\r\n *   -- DER-encoded X.509 certificate stored in OCTET STRING\r\n *\r\n * sdsiCertificate BAG-TYPE ::= {IA5String IDENTIFIED BY {certTypes 2}}\r\n * -- Base64-encoded SDSI certificate stored in IA5String\r\n *\r\n * CertTypes BAG-TYPE ::= {\r\n *   x509Certificate |\r\n *   sdsiCertificate,\r\n *   ... -- For future extensions\r\n * }\r\n */\nvar forge = require('./forge');\n\nrequire('./asn1');\n\nrequire('./hmac');\n\nrequire('./oids');\n\nrequire('./pkcs7asn1');\n\nrequire('./pbe');\n\nrequire('./random');\n\nrequire('./rsa');\n\nrequire('./sha1');\n\nrequire('./util');\n\nrequire('./x509'); // shortcut for asn.1 & PKI API\n\n\nvar asn1 = forge.asn1;\nvar pki = forge.pki; // shortcut for PKCS#12 API\n\nvar p12 = module.exports = forge.pkcs12 = forge.pkcs12 || {};\nvar contentInfoValidator = {\n  name: 'ContentInfo',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  // a ContentInfo\n  constructed: true,\n  value: [{\n    name: 'ContentInfo.contentType',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.OID,\n    constructed: false,\n    capture: 'contentType'\n  }, {\n    name: 'ContentInfo.content',\n    tagClass: asn1.Class.CONTEXT_SPECIFIC,\n    constructed: true,\n    captureAsn1: 'content'\n  }]\n};\nvar pfxValidator = {\n  name: 'PFX',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [{\n    name: 'PFX.version',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.INTEGER,\n    constructed: false,\n    capture: 'version'\n  }, contentInfoValidator, {\n    name: 'PFX.macData',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SEQUENCE,\n    constructed: true,\n    optional: true,\n    captureAsn1: 'mac',\n    value: [{\n      name: 'PFX.macData.mac',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.SEQUENCE,\n      // DigestInfo\n      constructed: true,\n      value: [{\n        name: 'PFX.macData.mac.digestAlgorithm',\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.SEQUENCE,\n        // DigestAlgorithmIdentifier\n        constructed: true,\n        value: [{\n          name: 'PFX.macData.mac.digestAlgorithm.algorithm',\n          tagClass: asn1.Class.UNIVERSAL,\n          type: asn1.Type.OID,\n          constructed: false,\n          capture: 'macAlgorithm'\n        }, {\n          name: 'PFX.macData.mac.digestAlgorithm.parameters',\n          tagClass: asn1.Class.UNIVERSAL,\n          captureAsn1: 'macAlgorithmParameters'\n        }]\n      }, {\n        name: 'PFX.macData.mac.digest',\n        tagClass: asn1.Class.UNIVERSAL,\n        type: asn1.Type.OCTETSTRING,\n        constructed: false,\n        capture: 'macDigest'\n      }]\n    }, {\n      name: 'PFX.macData.macSalt',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.OCTETSTRING,\n      constructed: false,\n      capture: 'macSalt'\n    }, {\n      name: 'PFX.macData.iterations',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Type.INTEGER,\n      constructed: false,\n      optional: true,\n      capture: 'macIterations'\n    }]\n  }]\n};\nvar safeBagValidator = {\n  name: 'SafeBag',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [{\n    name: 'SafeBag.bagId',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.OID,\n    constructed: false,\n    capture: 'bagId'\n  }, {\n    name: 'SafeBag.bagValue',\n    tagClass: asn1.Class.CONTEXT_SPECIFIC,\n    constructed: true,\n    captureAsn1: 'bagValue'\n  }, {\n    name: 'SafeBag.bagAttributes',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SET,\n    constructed: true,\n    optional: true,\n    capture: 'bagAttributes'\n  }]\n};\nvar attributeValidator = {\n  name: 'Attribute',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [{\n    name: 'Attribute.attrId',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.OID,\n    constructed: false,\n    capture: 'oid'\n  }, {\n    name: 'Attribute.attrValues',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.SET,\n    constructed: true,\n    capture: 'values'\n  }]\n};\nvar certBagValidator = {\n  name: 'CertBag',\n  tagClass: asn1.Class.UNIVERSAL,\n  type: asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [{\n    name: 'CertBag.certId',\n    tagClass: asn1.Class.UNIVERSAL,\n    type: asn1.Type.OID,\n    constructed: false,\n    capture: 'certId'\n  }, {\n    name: 'CertBag.certValue',\n    tagClass: asn1.Class.CONTEXT_SPECIFIC,\n    constructed: true,\n\n    /* So far we only support X.509 certificates (which are wrapped in\r\n       an OCTET STRING, hence hard code that here). */\n    value: [{\n      name: 'CertBag.certValue[0]',\n      tagClass: asn1.Class.UNIVERSAL,\n      type: asn1.Class.OCTETSTRING,\n      constructed: false,\n      capture: 'cert'\n    }]\n  }]\n};\n/**\r\n * Search SafeContents structure for bags with matching attributes.\r\n *\r\n * The search can optionally be narrowed by a certain bag type.\r\n *\r\n * @param safeContents the SafeContents structure to search in.\r\n * @param attrName the name of the attribute to compare against.\r\n * @param attrValue the attribute value to search for.\r\n * @param [bagType] bag type to narrow search by.\r\n *\r\n * @return an array of matching bags.\r\n */\n\nfunction _getBagsByAttribute(safeContents, attrName, attrValue, bagType) {\n  var result = [];\n\n  for (var i = 0; i < safeContents.length; i++) {\n    for (var j = 0; j < safeContents[i].safeBags.length; j++) {\n      var bag = safeContents[i].safeBags[j];\n\n      if (bagType !== undefined && bag.type !== bagType) {\n        continue;\n      } // only filter by bag type, no attribute specified\n\n\n      if (attrName === null) {\n        result.push(bag);\n        continue;\n      }\n\n      if (bag.attributes[attrName] !== undefined && bag.attributes[attrName].indexOf(attrValue) >= 0) {\n        result.push(bag);\n      }\n    }\n  }\n\n  return result;\n}\n/**\r\n * Converts a PKCS#12 PFX in ASN.1 notation into a PFX object.\r\n *\r\n * @param obj The PKCS#12 PFX in ASN.1 notation.\r\n * @param strict true to use strict DER decoding, false not to (default: true).\r\n * @param {String} password Password to decrypt with (optional).\r\n *\r\n * @return PKCS#12 PFX object.\r\n */\n\n\np12.pkcs12FromAsn1 = function (obj, strict, password) {\n  // handle args\n  if (typeof strict === 'string') {\n    password = strict;\n    strict = true;\n  } else if (strict === undefined) {\n    strict = true;\n  } // validate PFX and capture data\n\n\n  var capture = {};\n  var errors = [];\n\n  if (!asn1.validate(obj, pfxValidator, capture, errors)) {\n    var error = new Error('Cannot read PKCS#12 PFX. ' + 'ASN.1 object is not an PKCS#12 PFX.');\n    error.errors = error;\n    throw error;\n  }\n\n  var pfx = {\n    version: capture.version.charCodeAt(0),\n    safeContents: [],\n\n    /**\r\n     * Gets bags with matching attributes.\r\n     *\r\n     * @param filter the attributes to filter by:\r\n     *          [localKeyId] the localKeyId to search for.\r\n     *          [localKeyIdHex] the localKeyId in hex to search for.\r\n     *          [friendlyName] the friendly name to search for.\r\n     *          [bagType] bag type to narrow each attribute search by.\r\n     *\r\n     * @return a map of attribute type to an array of matching bags or, if no\r\n     *           attribute was given but a bag type, the map key will be the\r\n     *           bag type.\r\n     */\n    getBags: function (filter) {\n      var rval = {};\n      var localKeyId;\n\n      if ('localKeyId' in filter) {\n        localKeyId = filter.localKeyId;\n      } else if ('localKeyIdHex' in filter) {\n        localKeyId = forge.util.hexToBytes(filter.localKeyIdHex);\n      } // filter on bagType only\n\n\n      if (localKeyId === undefined && !('friendlyName' in filter) && 'bagType' in filter) {\n        rval[filter.bagType] = _getBagsByAttribute(pfx.safeContents, null, null, filter.bagType);\n      }\n\n      if (localKeyId !== undefined) {\n        rval.localKeyId = _getBagsByAttribute(pfx.safeContents, 'localKeyId', localKeyId, filter.bagType);\n      }\n\n      if ('friendlyName' in filter) {\n        rval.friendlyName = _getBagsByAttribute(pfx.safeContents, 'friendlyName', filter.friendlyName, filter.bagType);\n      }\n\n      return rval;\n    },\n\n    /**\r\n     * DEPRECATED: use getBags() instead.\r\n     *\r\n     * Get bags with matching friendlyName attribute.\r\n     *\r\n     * @param friendlyName the friendly name to search for.\r\n     * @param [bagType] bag type to narrow search by.\r\n     *\r\n     * @return an array of bags with matching friendlyName attribute.\r\n     */\n    getBagsByFriendlyName: function (friendlyName, bagType) {\n      return _getBagsByAttribute(pfx.safeContents, 'friendlyName', friendlyName, bagType);\n    },\n\n    /**\r\n     * DEPRECATED: use getBags() instead.\r\n     *\r\n     * Get bags with matching localKeyId attribute.\r\n     *\r\n     * @param localKeyId the localKeyId to search for.\r\n     * @param [bagType] bag type to narrow search by.\r\n     *\r\n     * @return an array of bags with matching localKeyId attribute.\r\n     */\n    getBagsByLocalKeyId: function (localKeyId, bagType) {\n      return _getBagsByAttribute(pfx.safeContents, 'localKeyId', localKeyId, bagType);\n    }\n  };\n\n  if (capture.version.charCodeAt(0) !== 3) {\n    var error = new Error('PKCS#12 PFX of version other than 3 not supported.');\n    error.version = capture.version.charCodeAt(0);\n    throw error;\n  }\n\n  if (asn1.derToOid(capture.contentType) !== pki.oids.data) {\n    var error = new Error('Only PKCS#12 PFX in password integrity mode supported.');\n    error.oid = asn1.derToOid(capture.contentType);\n    throw error;\n  }\n\n  var data = capture.content.value[0];\n\n  if (data.tagClass !== asn1.Class.UNIVERSAL || data.type !== asn1.Type.OCTETSTRING) {\n    throw new Error('PKCS#12 authSafe content data is not an OCTET STRING.');\n  }\n\n  data = _decodePkcs7Data(data); // check for MAC\n\n  if (capture.mac) {\n    var md = null;\n    var macKeyBytes = 0;\n    var macAlgorithm = asn1.derToOid(capture.macAlgorithm);\n\n    switch (macAlgorithm) {\n      case pki.oids.sha1:\n        md = forge.md.sha1.create();\n        macKeyBytes = 20;\n        break;\n\n      case pki.oids.sha256:\n        md = forge.md.sha256.create();\n        macKeyBytes = 32;\n        break;\n\n      case pki.oids.sha384:\n        md = forge.md.sha384.create();\n        macKeyBytes = 48;\n        break;\n\n      case pki.oids.sha512:\n        md = forge.md.sha512.create();\n        macKeyBytes = 64;\n        break;\n\n      case pki.oids.md5:\n        md = forge.md.md5.create();\n        macKeyBytes = 16;\n        break;\n    }\n\n    if (md === null) {\n      throw new Error('PKCS#12 uses unsupported MAC algorithm: ' + macAlgorithm);\n    } // verify MAC (iterations default to 1)\n\n\n    var macSalt = new forge.util.ByteBuffer(capture.macSalt);\n    var macIterations = 'macIterations' in capture ? parseInt(forge.util.bytesToHex(capture.macIterations), 16) : 1;\n    var macKey = p12.generateKey(password, macSalt, 3, macIterations, macKeyBytes, md);\n    var mac = forge.hmac.create();\n    mac.start(md, macKey);\n    mac.update(data.value);\n    var macValue = mac.getMac();\n\n    if (macValue.getBytes() !== capture.macDigest) {\n      throw new Error('PKCS#12 MAC could not be verified. Invalid password?');\n    }\n  }\n\n  _decodeAuthenticatedSafe(pfx, data.value, strict, password);\n\n  return pfx;\n};\n/**\r\n * Decodes PKCS#7 Data. PKCS#7 (RFC 2315) defines \"Data\" as an OCTET STRING,\r\n * but it is sometimes an OCTET STRING that is composed/constructed of chunks,\r\n * each its own OCTET STRING. This is BER-encoding vs. DER-encoding. This\r\n * function transforms this corner-case into the usual simple,\r\n * non-composed/constructed OCTET STRING.\r\n *\r\n * This function may be moved to ASN.1 at some point to better deal with\r\n * more BER-encoding issues, should they arise.\r\n *\r\n * @param data the ASN.1 Data object to transform.\r\n */\n\n\nfunction _decodePkcs7Data(data) {\n  // handle special case of \"chunked\" data content: an octet string composed\n  // of other octet strings\n  if (data.composed || data.constructed) {\n    var value = forge.util.createBuffer();\n\n    for (var i = 0; i < data.value.length; ++i) {\n      value.putBytes(data.value[i].value);\n    }\n\n    data.composed = data.constructed = false;\n    data.value = value.getBytes();\n  }\n\n  return data;\n}\n/**\r\n * Decode PKCS#12 AuthenticatedSafe (BER encoded) into PFX object.\r\n *\r\n * The AuthenticatedSafe is a BER-encoded SEQUENCE OF ContentInfo.\r\n *\r\n * @param pfx The PKCS#12 PFX object to fill.\r\n * @param {String} authSafe BER-encoded AuthenticatedSafe.\r\n * @param strict true to use strict DER decoding, false not to.\r\n * @param {String} password Password to decrypt with (optional).\r\n */\n\n\nfunction _decodeAuthenticatedSafe(pfx, authSafe, strict, password) {\n  authSafe = asn1.fromDer(authSafe, strict);\n  /* actually it's BER encoded */\n\n  if (authSafe.tagClass !== asn1.Class.UNIVERSAL || authSafe.type !== asn1.Type.SEQUENCE || authSafe.constructed !== true) {\n    throw new Error('PKCS#12 AuthenticatedSafe expected to be a ' + 'SEQUENCE OF ContentInfo');\n  }\n\n  for (var i = 0; i < authSafe.value.length; i++) {\n    var contentInfo = authSafe.value[i]; // validate contentInfo and capture data\n\n    var capture = {};\n    var errors = [];\n\n    if (!asn1.validate(contentInfo, contentInfoValidator, capture, errors)) {\n      var error = new Error('Cannot read ContentInfo.');\n      error.errors = errors;\n      throw error;\n    }\n\n    var obj = {\n      encrypted: false\n    };\n    var safeContents = null;\n    var data = capture.content.value[0];\n\n    switch (asn1.derToOid(capture.contentType)) {\n      case pki.oids.data:\n        if (data.tagClass !== asn1.Class.UNIVERSAL || data.type !== asn1.Type.OCTETSTRING) {\n          throw new Error('PKCS#12 SafeContents Data is not an OCTET STRING.');\n        }\n\n        safeContents = _decodePkcs7Data(data).value;\n        break;\n\n      case pki.oids.encryptedData:\n        safeContents = _decryptSafeContents(data, password);\n        obj.encrypted = true;\n        break;\n\n      default:\n        var error = new Error('Unsupported PKCS#12 contentType.');\n        error.contentType = asn1.derToOid(capture.contentType);\n        throw error;\n    }\n\n    obj.safeBags = _decodeSafeContents(safeContents, strict, password);\n    pfx.safeContents.push(obj);\n  }\n}\n/**\r\n * Decrypt PKCS#7 EncryptedData structure.\r\n *\r\n * @param data ASN.1 encoded EncryptedContentInfo object.\r\n * @param password The user-provided password.\r\n *\r\n * @return The decrypted SafeContents (ASN.1 object).\r\n */\n\n\nfunction _decryptSafeContents(data, password) {\n  var capture = {};\n  var errors = [];\n\n  if (!asn1.validate(data, forge.pkcs7.asn1.encryptedDataValidator, capture, errors)) {\n    var error = new Error('Cannot read EncryptedContentInfo.');\n    error.errors = errors;\n    throw error;\n  }\n\n  var oid = asn1.derToOid(capture.contentType);\n\n  if (oid !== pki.oids.data) {\n    var error = new Error('PKCS#12 EncryptedContentInfo ContentType is not Data.');\n    error.oid = oid;\n    throw error;\n  } // get cipher\n\n\n  oid = asn1.derToOid(capture.encAlgorithm);\n  var cipher = pki.pbe.getCipher(oid, capture.encParameter, password); // get encrypted data\n\n  var encryptedContentAsn1 = _decodePkcs7Data(capture.encryptedContentAsn1);\n\n  var encrypted = forge.util.createBuffer(encryptedContentAsn1.value);\n  cipher.update(encrypted);\n\n  if (!cipher.finish()) {\n    throw new Error('Failed to decrypt PKCS#12 SafeContents.');\n  }\n\n  return cipher.output.getBytes();\n}\n/**\r\n * Decode PKCS#12 SafeContents (BER-encoded) into array of Bag objects.\r\n *\r\n * The safeContents is a BER-encoded SEQUENCE OF SafeBag.\r\n *\r\n * @param {String} safeContents BER-encoded safeContents.\r\n * @param strict true to use strict DER decoding, false not to.\r\n * @param {String} password Password to decrypt with (optional).\r\n *\r\n * @return {Array} Array of Bag objects.\r\n */\n\n\nfunction _decodeSafeContents(safeContents, strict, password) {\n  // if strict and no safe contents, return empty safes\n  if (!strict && safeContents.length === 0) {\n    return [];\n  } // actually it's BER-encoded\n\n\n  safeContents = asn1.fromDer(safeContents, strict);\n\n  if (safeContents.tagClass !== asn1.Class.UNIVERSAL || safeContents.type !== asn1.Type.SEQUENCE || safeContents.constructed !== true) {\n    throw new Error('PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag.');\n  }\n\n  var res = [];\n\n  for (var i = 0; i < safeContents.value.length; i++) {\n    var safeBag = safeContents.value[i]; // validate SafeBag and capture data\n\n    var capture = {};\n    var errors = [];\n\n    if (!asn1.validate(safeBag, safeBagValidator, capture, errors)) {\n      var error = new Error('Cannot read SafeBag.');\n      error.errors = errors;\n      throw error;\n    }\n    /* Create bag object and push to result array. */\n\n\n    var bag = {\n      type: asn1.derToOid(capture.bagId),\n      attributes: _decodeBagAttributes(capture.bagAttributes)\n    };\n    res.push(bag);\n    var validator, decoder;\n    var bagAsn1 = capture.bagValue.value[0];\n\n    switch (bag.type) {\n      case pki.oids.pkcs8ShroudedKeyBag:\n        /* bagAsn1 has a EncryptedPrivateKeyInfo, which we need to decrypt.\r\n           Afterwards we can handle it like a keyBag,\r\n           which is a PrivateKeyInfo. */\n        bagAsn1 = pki.decryptPrivateKeyInfo(bagAsn1, password);\n\n        if (bagAsn1 === null) {\n          throw new Error('Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?');\n        }\n\n      /* fall through */\n\n      case pki.oids.keyBag:\n        /* A PKCS#12 keyBag is a simple PrivateKeyInfo as understood by our\r\n           PKI module, hence we don't have to do validation/capturing here,\r\n           just pass what we already got. */\n        try {\n          bag.key = pki.privateKeyFromAsn1(bagAsn1);\n        } catch (e) {\n          // ignore unknown key type, pass asn1 value\n          bag.key = null;\n          bag.asn1 = bagAsn1;\n        }\n\n        continue;\n\n      /* Nothing more to do. */\n\n      case pki.oids.certBag:\n        /* A PKCS#12 certBag can wrap both X.509 and sdsi certificates.\r\n           Therefore put the SafeBag content through another validator to\r\n           capture the fields.  Afterwards check & store the results. */\n        validator = certBagValidator;\n\n        decoder = function () {\n          if (asn1.derToOid(capture.certId) !== pki.oids.x509Certificate) {\n            var error = new Error('Unsupported certificate type, only X.509 supported.');\n            error.oid = asn1.derToOid(capture.certId);\n            throw error;\n          } // true=produce cert hash\n\n\n          var certAsn1 = asn1.fromDer(capture.cert, strict);\n\n          try {\n            bag.cert = pki.certificateFromAsn1(certAsn1, true);\n          } catch (e) {\n            // ignore unknown cert type, pass asn1 value\n            bag.cert = null;\n            bag.asn1 = certAsn1;\n          }\n        };\n\n        break;\n\n      default:\n        var error = new Error('Unsupported PKCS#12 SafeBag type.');\n        error.oid = bag.type;\n        throw error;\n    }\n    /* Validate SafeBag value (i.e. CertBag, etc.) and capture data if needed. */\n\n\n    if (validator !== undefined && !asn1.validate(bagAsn1, validator, capture, errors)) {\n      var error = new Error('Cannot read PKCS#12 ' + validator.name);\n      error.errors = errors;\n      throw error;\n    }\n    /* Call decoder function from above to store the results. */\n\n\n    decoder();\n  }\n\n  return res;\n}\n/**\r\n * Decode PKCS#12 SET OF PKCS12Attribute into JavaScript object.\r\n *\r\n * @param attributes SET OF PKCS12Attribute (ASN.1 object).\r\n *\r\n * @return the decoded attributes.\r\n */\n\n\nfunction _decodeBagAttributes(attributes) {\n  var decodedAttrs = {};\n\n  if (attributes !== undefined) {\n    for (var i = 0; i < attributes.length; ++i) {\n      var capture = {};\n      var errors = [];\n\n      if (!asn1.validate(attributes[i], attributeValidator, capture, errors)) {\n        var error = new Error('Cannot read PKCS#12 BagAttribute.');\n        error.errors = errors;\n        throw error;\n      }\n\n      var oid = asn1.derToOid(capture.oid);\n\n      if (pki.oids[oid] === undefined) {\n        // unsupported attribute type, ignore.\n        continue;\n      }\n\n      decodedAttrs[pki.oids[oid]] = [];\n\n      for (var j = 0; j < capture.values.length; ++j) {\n        decodedAttrs[pki.oids[oid]].push(capture.values[j].value);\n      }\n    }\n  }\n\n  return decodedAttrs;\n}\n/**\r\n * Wraps a private key and certificate in a PKCS#12 PFX wrapper. If a\r\n * password is provided then the private key will be encrypted.\r\n *\r\n * An entire certificate chain may also be included. To do this, pass\r\n * an array for the \"cert\" parameter where the first certificate is\r\n * the one that is paired with the private key and each subsequent one\r\n * verifies the previous one. The certificates may be in PEM format or\r\n * have been already parsed by Forge.\r\n *\r\n * @todo implement password-based-encryption for the whole package\r\n *\r\n * @param key the private key.\r\n * @param cert the certificate (may be an array of certificates in order\r\n *          to specify a certificate chain).\r\n * @param password the password to use, null for none.\r\n * @param options:\r\n *          algorithm the encryption algorithm to use\r\n *            ('aes128', 'aes192', 'aes256', '3des'), defaults to 'aes128'.\r\n *          count the iteration count to use.\r\n *          saltSize the salt size to use.\r\n *          useMac true to include a MAC, false not to, defaults to true.\r\n *          localKeyId the local key ID to use, in hex.\r\n *          friendlyName the friendly name to use.\r\n *          generateLocalKeyId true to generate a random local key ID,\r\n *            false not to, defaults to true.\r\n *\r\n * @return the PKCS#12 PFX ASN.1 object.\r\n */\n\n\np12.toPkcs12Asn1 = function (key, cert, password, options) {\n  // set default options\n  options = options || {};\n  options.saltSize = options.saltSize || 8;\n  options.count = options.count || 2048;\n  options.algorithm = options.algorithm || options.encAlgorithm || 'aes128';\n\n  if (!('useMac' in options)) {\n    options.useMac = true;\n  }\n\n  if (!('localKeyId' in options)) {\n    options.localKeyId = null;\n  }\n\n  if (!('generateLocalKeyId' in options)) {\n    options.generateLocalKeyId = true;\n  }\n\n  var localKeyId = options.localKeyId;\n  var bagAttrs;\n\n  if (localKeyId !== null) {\n    localKeyId = forge.util.hexToBytes(localKeyId);\n  } else if (options.generateLocalKeyId) {\n    // use SHA-1 of paired cert, if available\n    if (cert) {\n      var pairedCert = forge.util.isArray(cert) ? cert[0] : cert;\n\n      if (typeof pairedCert === 'string') {\n        pairedCert = pki.certificateFromPem(pairedCert);\n      }\n\n      var sha1 = forge.md.sha1.create();\n      sha1.update(asn1.toDer(pki.certificateToAsn1(pairedCert)).getBytes());\n      localKeyId = sha1.digest().getBytes();\n    } else {\n      // FIXME: consider using SHA-1 of public key (which can be generated\n      // from private key components), see: cert.generateSubjectKeyIdentifier\n      // generate random bytes\n      localKeyId = forge.random.getBytes(20);\n    }\n  }\n\n  var attrs = [];\n\n  if (localKeyId !== null) {\n    attrs.push( // localKeyID\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// attrId\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.localKeyId).getBytes()), // attrValues\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, localKeyId)])]));\n  }\n\n  if ('friendlyName' in options) {\n    attrs.push( // friendlyName\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// attrId\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.friendlyName).getBytes()), // attrValues\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BMPSTRING, false, options.friendlyName)])]));\n  }\n\n  if (attrs.length > 0) {\n    bagAttrs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, attrs);\n  } // collect contents for AuthenticatedSafe\n\n\n  var contents = []; // create safe bag(s) for certificate chain\n\n  var chain = [];\n\n  if (cert !== null) {\n    if (forge.util.isArray(cert)) {\n      chain = cert;\n    } else {\n      chain = [cert];\n    }\n  }\n\n  var certSafeBags = [];\n\n  for (var i = 0; i < chain.length; ++i) {\n    // convert cert from PEM as necessary\n    cert = chain[i];\n\n    if (typeof cert === 'string') {\n      cert = pki.certificateFromPem(cert);\n    } // SafeBag\n\n\n    var certBagAttrs = i === 0 ? bagAttrs : undefined;\n    var certAsn1 = pki.certificateToAsn1(cert);\n    var certSafeBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// bagId\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.certBag).getBytes()), // bagValue\n    asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [// CertBag\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// certId\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.x509Certificate).getBytes()), // certValue (x509Certificate)\n    asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(certAsn1).getBytes())])])]), // bagAttributes (OPTIONAL)\n    certBagAttrs]);\n    certSafeBags.push(certSafeBag);\n  }\n\n  if (certSafeBags.length > 0) {\n    // SafeContents\n    var certSafeContents = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, certSafeBags); // ContentInfo\n\n    var certCI = // PKCS#7 ContentInfo\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// contentType\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, // OID for the content type is 'data'\n    asn1.oidToDer(pki.oids.data).getBytes()), // content\n    asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(certSafeContents).getBytes())])]);\n    contents.push(certCI);\n  } // create safe contents for private key\n\n\n  var keyBag = null;\n\n  if (key !== null) {\n    // SafeBag\n    var pkAsn1 = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(key));\n\n    if (password === null) {\n      // no encryption\n      keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// bagId\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.keyBag).getBytes()), // bagValue\n      asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [// PrivateKeyInfo\n      pkAsn1]), // bagAttributes (OPTIONAL)\n      bagAttrs]);\n    } else {\n      // encrypted PrivateKeyInfo\n      keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// bagId\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.pkcs8ShroudedKeyBag).getBytes()), // bagValue\n      asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [// EncryptedPrivateKeyInfo\n      pki.encryptPrivateKeyInfo(pkAsn1, password, options)]), // bagAttributes (OPTIONAL)\n      bagAttrs]);\n    } // SafeContents\n\n\n    var keySafeContents = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [keyBag]); // ContentInfo\n\n    var keyCI = // PKCS#7 ContentInfo\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// contentType\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, // OID for the content type is 'data'\n    asn1.oidToDer(pki.oids.data).getBytes()), // content\n    asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(keySafeContents).getBytes())])]);\n    contents.push(keyCI);\n  } // create AuthenticatedSafe by stringing together the contents\n\n\n  var safe = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, contents);\n  var macData;\n\n  if (options.useMac) {\n    // MacData\n    var sha1 = forge.md.sha1.create();\n    var macSalt = new forge.util.ByteBuffer(forge.random.getBytes(options.saltSize));\n    var count = options.count; // 160-bit key\n\n    var key = p12.generateKey(password, macSalt, 3, count, 20);\n    var mac = forge.hmac.create();\n    mac.start(sha1, key);\n    mac.update(asn1.toDer(safe).getBytes());\n    var macValue = mac.getMac();\n    macData = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// mac DigestInfo\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// digestAlgorithm\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// algorithm = SHA-1\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.sha1).getBytes()), // parameters = Null\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')]), // digest\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, macValue.getBytes())]), // macSalt OCTET STRING\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, macSalt.getBytes()), // iterations INTEGER (XXX: Only support count < 65536)\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(count).getBytes())]);\n  } // PFX\n\n\n  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// version (3)\n  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(3).getBytes()), // PKCS#7 ContentInfo\n  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [// contentType\n  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, // OID for the content type is 'data'\n  asn1.oidToDer(pki.oids.data).getBytes()), // content\n  asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(safe).getBytes())])]), macData]);\n};\n/**\r\n * Derives a PKCS#12 key.\r\n *\r\n * @param password the password to derive the key material from, null or\r\n *          undefined for none.\r\n * @param salt the salt, as a ByteBuffer, to use.\r\n * @param id the PKCS#12 ID byte (1 = key material, 2 = IV, 3 = MAC).\r\n * @param iter the iteration count.\r\n * @param n the number of bytes to derive from the password.\r\n * @param md the message digest to use, defaults to SHA-1.\r\n *\r\n * @return a ByteBuffer with the bytes derived from the password.\r\n */\n\n\np12.generateKey = forge.pbe.generatePkcs12Key;","map":{"version":3,"sources":["C:/Users/ibott/MajorGroupProject/node_modules/node-forge/lib/pkcs12.js"],"names":["forge","require","asn1","pki","p12","module","exports","pkcs12","contentInfoValidator","name","tagClass","Class","UNIVERSAL","type","Type","SEQUENCE","constructed","value","OID","capture","CONTEXT_SPECIFIC","captureAsn1","pfxValidator","INTEGER","optional","OCTETSTRING","safeBagValidator","SET","attributeValidator","certBagValidator","_getBagsByAttribute","safeContents","attrName","attrValue","bagType","result","i","length","j","safeBags","bag","undefined","push","attributes","indexOf","pkcs12FromAsn1","obj","strict","password","errors","validate","error","Error","pfx","version","charCodeAt","getBags","filter","rval","localKeyId","util","hexToBytes","localKeyIdHex","friendlyName","getBagsByFriendlyName","getBagsByLocalKeyId","derToOid","contentType","oids","data","oid","content","_decodePkcs7Data","mac","md","macKeyBytes","macAlgorithm","sha1","create","sha256","sha384","sha512","md5","macSalt","ByteBuffer","macIterations","parseInt","bytesToHex","macKey","generateKey","hmac","start","update","macValue","getMac","getBytes","macDigest","_decodeAuthenticatedSafe","composed","createBuffer","putBytes","authSafe","fromDer","contentInfo","encrypted","encryptedData","_decryptSafeContents","_decodeSafeContents","pkcs7","encryptedDataValidator","encAlgorithm","cipher","pbe","getCipher","encParameter","encryptedContentAsn1","finish","output","res","safeBag","bagId","_decodeBagAttributes","bagAttributes","validator","decoder","bagAsn1","bagValue","pkcs8ShroudedKeyBag","decryptPrivateKeyInfo","keyBag","key","privateKeyFromAsn1","e","certBag","certId","x509Certificate","certAsn1","cert","certificateFromAsn1","decodedAttrs","values","toPkcs12Asn1","options","saltSize","count","algorithm","useMac","generateLocalKeyId","bagAttrs","pairedCert","isArray","certificateFromPem","toDer","certificateToAsn1","digest","random","attrs","oidToDer","BMPSTRING","contents","chain","certSafeBags","certBagAttrs","certSafeBag","certSafeContents","certCI","pkAsn1","wrapRsaPrivateKey","privateKeyToAsn1","encryptPrivateKeyInfo","keySafeContents","keyCI","safe","macData","NULL","integerToDer","generatePkcs12Key"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIA,KAAK,GAAGC,OAAO,CAAC,SAAD,CAAnB;;AACAA,OAAO,CAAC,QAAD,CAAP;;AACAA,OAAO,CAAC,QAAD,CAAP;;AACAA,OAAO,CAAC,QAAD,CAAP;;AACAA,OAAO,CAAC,aAAD,CAAP;;AACAA,OAAO,CAAC,OAAD,CAAP;;AACAA,OAAO,CAAC,UAAD,CAAP;;AACAA,OAAO,CAAC,OAAD,CAAP;;AACAA,OAAO,CAAC,QAAD,CAAP;;AACAA,OAAO,CAAC,QAAD,CAAP;;AACAA,OAAO,CAAC,QAAD,CAAP,C,CAEA;;;AACA,IAAIC,IAAI,GAAGF,KAAK,CAACE,IAAjB;AACA,IAAIC,GAAG,GAAGH,KAAK,CAACG,GAAhB,C,CAEA;;AACA,IAAIC,GAAG,GAAGC,MAAM,CAACC,OAAP,GAAiBN,KAAK,CAACO,MAAN,GAAeP,KAAK,CAACO,MAAN,IAAgB,EAA1D;AAEA,IAAIC,oBAAoB,GAAG;AACzBC,EAAAA,IAAI,EAAE,aADmB;AAEzBC,EAAAA,QAAQ,EAAER,IAAI,CAACS,KAAL,CAAWC,SAFI;AAGzBC,EAAAA,IAAI,EAAEX,IAAI,CAACY,IAAL,CAAUC,QAHS;AAGE;AAC3BC,EAAAA,WAAW,EAAE,IAJY;AAKzBC,EAAAA,KAAK,EAAE,CAAC;AACNR,I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","sourcesContent":["/**\r\n * Javascript implementation of PKCS#12.\r\n *\r\n * @author Dave Longley\r\n * @author Stefan Siegl <stesie@brokenpipe.de>\r\n *\r\n * Copyright (c) 2010-2014 Digital Bazaar, Inc.\r\n * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>\r\n *\r\n * The ASN.1 representation of PKCS#12 is as follows\r\n * (see ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-12/pkcs-12-tc1.pdf for details)\r\n *\r\n * PFX ::= SEQUENCE {\r\n *   version  INTEGER {v3(3)}(v3,...),\r\n *   authSafe ContentInfo,\r\n *   macData  MacData OPTIONAL\r\n * }\r\n *\r\n * MacData ::= SEQUENCE {\r\n *   mac DigestInfo,\r\n *   macSalt OCTET STRING,\r\n *   iterations INTEGER DEFAULT 1\r\n * }\r\n * Note: The iterations default is for historical reasons and its use is\r\n * deprecated. A higher value, like 1024, is recommended.\r\n *\r\n * DigestInfo is defined in PKCS#7 as follows:\r\n *\r\n * DigestInfo ::= SEQUENCE {\r\n *   digestAlgorithm DigestAlgorithmIdentifier,\r\n *   digest Digest\r\n * }\r\n *\r\n * DigestAlgorithmIdentifier ::= AlgorithmIdentifier\r\n *\r\n * The AlgorithmIdentifier contains an Object Identifier (OID) and parameters\r\n * for the algorithm, if any. In the case of SHA1 there is none.\r\n *\r\n * AlgorithmIdentifer ::= SEQUENCE {\r\n *    algorithm OBJECT IDENTIFIER,\r\n *    parameters ANY DEFINED BY algorithm OPTIONAL\r\n * }\r\n *\r\n * Digest ::= OCTET STRING\r\n *\r\n *\r\n * ContentInfo ::= SEQUENCE {\r\n *   contentType ContentType,\r\n *   content     [0] EXPLICIT ANY DEFINED BY contentType OPTIONAL\r\n * }\r\n *\r\n * ContentType ::= OBJECT IDENTIFIER\r\n *\r\n * AuthenticatedSafe ::= SEQUENCE OF ContentInfo\r\n * -- Data if unencrypted\r\n * -- EncryptedData if password-encrypted\r\n * -- EnvelopedData if public key-encrypted\r\n *\r\n *\r\n * SafeContents ::= SEQUENCE OF SafeBag\r\n *\r\n * SafeBag ::= SEQUENCE {\r\n *   bagId     BAG-TYPE.&id ({PKCS12BagSet})\r\n *   bagValue  [0] EXPLICIT BAG-TYPE.&Type({PKCS12BagSet}{@bagId}),\r\n *   bagAttributes SET OF PKCS12Attribute OPTIONAL\r\n * }\r\n *\r\n * PKCS12Attribute ::= SEQUENCE {\r\n *   attrId ATTRIBUTE.&id ({PKCS12AttrSet}),\r\n *   attrValues SET OF ATTRIBUTE.&Type ({PKCS12AttrSet}{@attrId})\r\n * } -- This type is compatible with the X.500 type 'Attribute'\r\n *\r\n * PKCS12AttrSet ATTRIBUTE ::= {\r\n *   friendlyName | -- from PKCS #9\r\n *   localKeyId, -- from PKCS #9\r\n *   ... -- Other attributes are allowed\r\n * }\r\n *\r\n * CertBag ::= SEQUENCE {\r\n *   certId    BAG-TYPE.&id   ({CertTypes}),\r\n *   certValue [0] EXPLICIT BAG-TYPE.&Type ({CertTypes}{@certId})\r\n * }\r\n *\r\n * x509Certificate BAG-TYPE ::= {OCTET STRING IDENTIFIED BY {certTypes 1}}\r\n *   -- DER-encoded X.509 certificate stored in OCTET STRING\r\n *\r\n * sdsiCertificate BAG-TYPE ::= {IA5String IDENTIFIED BY {certTypes 2}}\r\n * -- Base64-encoded SDSI certificate stored in IA5String\r\n *\r\n * CertTypes BAG-TYPE ::= {\r\n *   x509Certificate |\r\n *   sdsiCertificate,\r\n *   ... -- For future extensions\r\n * }\r\n */\r\nvar forge = require('./forge');\r\nrequire('./asn1');\r\nrequire('./hmac');\r\nrequire('./oids');\r\nrequire('./pkcs7asn1');\r\nrequire('./pbe');\r\nrequire('./random');\r\nrequire('./rsa');\r\nrequire('./sha1');\r\nrequire('./util');\r\nrequire('./x509');\r\n\r\n// shortcut for asn.1 & PKI API\r\nvar asn1 = forge.asn1;\r\nvar pki = forge.pki;\r\n\r\n// shortcut for PKCS#12 API\r\nvar p12 = module.exports = forge.pkcs12 = forge.pkcs12 || {};\r\n\r\nvar contentInfoValidator = {\r\n  name: 'ContentInfo',\r\n  tagClass: asn1.Class.UNIVERSAL,\r\n  type: asn1.Type.SEQUENCE,  // a ContentInfo\r\n  constructed: true,\r\n  value: [{\r\n    name: 'ContentInfo.contentType',\r\n    tagClass: asn1.Class.UNIVERSAL,\r\n    type: asn1.Type.OID,\r\n    constructed: false,\r\n    capture: 'contentType'\r\n  }, {\r\n    name: 'ContentInfo.content',\r\n    tagClass: asn1.Class.CONTEXT_SPECIFIC,\r\n    constructed: true,\r\n    captureAsn1: 'content'\r\n  }]\r\n};\r\n\r\nvar pfxValidator = {\r\n  name: 'PFX',\r\n  tagClass: asn1.Class.UNIVERSAL,\r\n  type: asn1.Type.SEQUENCE,\r\n  constructed: true,\r\n  value: [{\r\n    name: 'PFX.version',\r\n    tagClass: asn1.Class.UNIVERSAL,\r\n    type: asn1.Type.INTEGER,\r\n    constructed: false,\r\n    capture: 'version'\r\n  },\r\n  contentInfoValidator, {\r\n    name: 'PFX.macData',\r\n    tagClass: asn1.Class.UNIVERSAL,\r\n    type: asn1.Type.SEQUENCE,\r\n    constructed: true,\r\n    optional: true,\r\n    captureAsn1: 'mac',\r\n    value: [{\r\n      name: 'PFX.macData.mac',\r\n      tagClass: asn1.Class.UNIVERSAL,\r\n      type: asn1.Type.SEQUENCE,  // DigestInfo\r\n      constructed: true,\r\n      value: [{\r\n        name: 'PFX.macData.mac.digestAlgorithm',\r\n        tagClass: asn1.Class.UNIVERSAL,\r\n        type: asn1.Type.SEQUENCE,  // DigestAlgorithmIdentifier\r\n        constructed: true,\r\n        value: [{\r\n          name: 'PFX.macData.mac.digestAlgorithm.algorithm',\r\n          tagClass: asn1.Class.UNIVERSAL,\r\n          type: asn1.Type.OID,\r\n          constructed: false,\r\n          capture: 'macAlgorithm'\r\n        }, {\r\n          name: 'PFX.macData.mac.digestAlgorithm.parameters',\r\n          tagClass: asn1.Class.UNIVERSAL,\r\n          captureAsn1: 'macAlgorithmParameters'\r\n        }]\r\n      }, {\r\n        name: 'PFX.macData.mac.digest',\r\n        tagClass: asn1.Class.UNIVERSAL,\r\n        type: asn1.Type.OCTETSTRING,\r\n        constructed: false,\r\n        capture: 'macDigest'\r\n      }]\r\n    }, {\r\n      name: 'PFX.macData.macSalt',\r\n      tagClass: asn1.Class.UNIVERSAL,\r\n      type: asn1.Type.OCTETSTRING,\r\n      constructed: false,\r\n      capture: 'macSalt'\r\n    }, {\r\n      name: 'PFX.macData.iterations',\r\n      tagClass: asn1.Class.UNIVERSAL,\r\n      type: asn1.Type.INTEGER,\r\n      constructed: false,\r\n      optional: true,\r\n      capture: 'macIterations'\r\n    }]\r\n  }]\r\n};\r\n\r\nvar safeBagValidator = {\r\n  name: 'SafeBag',\r\n  tagClass: asn1.Class.UNIVERSAL,\r\n  type: asn1.Type.SEQUENCE,\r\n  constructed: true,\r\n  value: [{\r\n    name: 'SafeBag.bagId',\r\n    tagClass: asn1.Class.UNIVERSAL,\r\n    type: asn1.Type.OID,\r\n    constructed: false,\r\n    capture: 'bagId'\r\n  }, {\r\n    name: 'SafeBag.bagValue',\r\n    tagClass: asn1.Class.CONTEXT_SPECIFIC,\r\n    constructed: true,\r\n    captureAsn1: 'bagValue'\r\n  }, {\r\n    name: 'SafeBag.bagAttributes',\r\n    tagClass: asn1.Class.UNIVERSAL,\r\n    type: asn1.Type.SET,\r\n    constructed: true,\r\n    optional: true,\r\n    capture: 'bagAttributes'\r\n  }]\r\n};\r\n\r\nvar attributeValidator = {\r\n  name: 'Attribute',\r\n  tagClass: asn1.Class.UNIVERSAL,\r\n  type: asn1.Type.SEQUENCE,\r\n  constructed: true,\r\n  value: [{\r\n    name: 'Attribute.attrId',\r\n    tagClass: asn1.Class.UNIVERSAL,\r\n    type: asn1.Type.OID,\r\n    constructed: false,\r\n    capture: 'oid'\r\n  }, {\r\n    name: 'Attribute.attrValues',\r\n    tagClass: asn1.Class.UNIVERSAL,\r\n    type: asn1.Type.SET,\r\n    constructed: true,\r\n    capture: 'values'\r\n  }]\r\n};\r\n\r\nvar certBagValidator = {\r\n  name: 'CertBag',\r\n  tagClass: asn1.Class.UNIVERSAL,\r\n  type: asn1.Type.SEQUENCE,\r\n  constructed: true,\r\n  value: [{\r\n    name: 'CertBag.certId',\r\n    tagClass: asn1.Class.UNIVERSAL,\r\n    type: asn1.Type.OID,\r\n    constructed: false,\r\n    capture: 'certId'\r\n  }, {\r\n    name: 'CertBag.certValue',\r\n    tagClass: asn1.Class.CONTEXT_SPECIFIC,\r\n    constructed: true,\r\n    /* So far we only support X.509 certificates (which are wrapped in\r\n       an OCTET STRING, hence hard code that here). */\r\n    value: [{\r\n      name: 'CertBag.certValue[0]',\r\n      tagClass: asn1.Class.UNIVERSAL,\r\n      type: asn1.Class.OCTETSTRING,\r\n      constructed: false,\r\n      capture: 'cert'\r\n    }]\r\n  }]\r\n};\r\n\r\n/**\r\n * Search SafeContents structure for bags with matching attributes.\r\n *\r\n * The search can optionally be narrowed by a certain bag type.\r\n *\r\n * @param safeContents the SafeContents structure to search in.\r\n * @param attrName the name of the attribute to compare against.\r\n * @param attrValue the attribute value to search for.\r\n * @param [bagType] bag type to narrow search by.\r\n *\r\n * @return an array of matching bags.\r\n */\r\nfunction _getBagsByAttribute(safeContents, attrName, attrValue, bagType) {\r\n  var result = [];\r\n\r\n  for(var i = 0; i < safeContents.length; i++) {\r\n    for(var j = 0; j < safeContents[i].safeBags.length; j++) {\r\n      var bag = safeContents[i].safeBags[j];\r\n      if(bagType !== undefined && bag.type !== bagType) {\r\n        continue;\r\n      }\r\n      // only filter by bag type, no attribute specified\r\n      if(attrName === null) {\r\n        result.push(bag);\r\n        continue;\r\n      }\r\n      if(bag.attributes[attrName] !== undefined &&\r\n        bag.attributes[attrName].indexOf(attrValue) >= 0) {\r\n        result.push(bag);\r\n      }\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * Converts a PKCS#12 PFX in ASN.1 notation into a PFX object.\r\n *\r\n * @param obj The PKCS#12 PFX in ASN.1 notation.\r\n * @param strict true to use strict DER decoding, false not to (default: true).\r\n * @param {String} password Password to decrypt with (optional).\r\n *\r\n * @return PKCS#12 PFX object.\r\n */\r\np12.pkcs12FromAsn1 = function(obj, strict, password) {\r\n  // handle args\r\n  if(typeof strict === 'string') {\r\n    password = strict;\r\n    strict = true;\r\n  } else if(strict === undefined) {\r\n    strict = true;\r\n  }\r\n\r\n  // validate PFX and capture data\r\n  var capture = {};\r\n  var errors = [];\r\n  if(!asn1.validate(obj, pfxValidator, capture, errors)) {\r\n    var error = new Error('Cannot read PKCS#12 PFX. ' +\r\n      'ASN.1 object is not an PKCS#12 PFX.');\r\n    error.errors = error;\r\n    throw error;\r\n  }\r\n\r\n  var pfx = {\r\n    version: capture.version.charCodeAt(0),\r\n    safeContents: [],\r\n\r\n    /**\r\n     * Gets bags with matching attributes.\r\n     *\r\n     * @param filter the attributes to filter by:\r\n     *          [localKeyId] the localKeyId to search for.\r\n     *          [localKeyIdHex] the localKeyId in hex to search for.\r\n     *          [friendlyName] the friendly name to search for.\r\n     *          [bagType] bag type to narrow each attribute search by.\r\n     *\r\n     * @return a map of attribute type to an array of matching bags or, if no\r\n     *           attribute was given but a bag type, the map key will be the\r\n     *           bag type.\r\n     */\r\n    getBags: function(filter) {\r\n      var rval = {};\r\n\r\n      var localKeyId;\r\n      if('localKeyId' in filter) {\r\n        localKeyId = filter.localKeyId;\r\n      } else if('localKeyIdHex' in filter) {\r\n        localKeyId = forge.util.hexToBytes(filter.localKeyIdHex);\r\n      }\r\n\r\n      // filter on bagType only\r\n      if(localKeyId === undefined && !('friendlyName' in filter) &&\r\n        'bagType' in filter) {\r\n        rval[filter.bagType] = _getBagsByAttribute(\r\n          pfx.safeContents, null, null, filter.bagType);\r\n      }\r\n\r\n      if(localKeyId !== undefined) {\r\n        rval.localKeyId = _getBagsByAttribute(\r\n          pfx.safeContents, 'localKeyId',\r\n          localKeyId, filter.bagType);\r\n      }\r\n      if('friendlyName' in filter) {\r\n        rval.friendlyName = _getBagsByAttribute(\r\n          pfx.safeContents, 'friendlyName',\r\n          filter.friendlyName, filter.bagType);\r\n      }\r\n\r\n      return rval;\r\n    },\r\n\r\n    /**\r\n     * DEPRECATED: use getBags() instead.\r\n     *\r\n     * Get bags with matching friendlyName attribute.\r\n     *\r\n     * @param friendlyName the friendly name to search for.\r\n     * @param [bagType] bag type to narrow search by.\r\n     *\r\n     * @return an array of bags with matching friendlyName attribute.\r\n     */\r\n    getBagsByFriendlyName: function(friendlyName, bagType) {\r\n      return _getBagsByAttribute(\r\n        pfx.safeContents, 'friendlyName', friendlyName, bagType);\r\n    },\r\n\r\n    /**\r\n     * DEPRECATED: use getBags() instead.\r\n     *\r\n     * Get bags with matching localKeyId attribute.\r\n     *\r\n     * @param localKeyId the localKeyId to search for.\r\n     * @param [bagType] bag type to narrow search by.\r\n     *\r\n     * @return an array of bags with matching localKeyId attribute.\r\n     */\r\n    getBagsByLocalKeyId: function(localKeyId, bagType) {\r\n      return _getBagsByAttribute(\r\n        pfx.safeContents, 'localKeyId', localKeyId, bagType);\r\n    }\r\n  };\r\n\r\n  if(capture.version.charCodeAt(0) !== 3) {\r\n    var error = new Error('PKCS#12 PFX of version other than 3 not supported.');\r\n    error.version = capture.version.charCodeAt(0);\r\n    throw error;\r\n  }\r\n\r\n  if(asn1.derToOid(capture.contentType) !== pki.oids.data) {\r\n    var error = new Error('Only PKCS#12 PFX in password integrity mode supported.');\r\n    error.oid = asn1.derToOid(capture.contentType);\r\n    throw error;\r\n  }\r\n\r\n  var data = capture.content.value[0];\r\n  if(data.tagClass !== asn1.Class.UNIVERSAL ||\r\n     data.type !== asn1.Type.OCTETSTRING) {\r\n    throw new Error('PKCS#12 authSafe content data is not an OCTET STRING.');\r\n  }\r\n  data = _decodePkcs7Data(data);\r\n\r\n  // check for MAC\r\n  if(capture.mac) {\r\n    var md = null;\r\n    var macKeyBytes = 0;\r\n    var macAlgorithm = asn1.derToOid(capture.macAlgorithm);\r\n    switch(macAlgorithm) {\r\n    case pki.oids.sha1:\r\n      md = forge.md.sha1.create();\r\n      macKeyBytes = 20;\r\n      break;\r\n    case pki.oids.sha256:\r\n      md = forge.md.sha256.create();\r\n      macKeyBytes = 32;\r\n      break;\r\n    case pki.oids.sha384:\r\n      md = forge.md.sha384.create();\r\n      macKeyBytes = 48;\r\n      break;\r\n    case pki.oids.sha512:\r\n      md = forge.md.sha512.create();\r\n      macKeyBytes = 64;\r\n      break;\r\n    case pki.oids.md5:\r\n      md = forge.md.md5.create();\r\n      macKeyBytes = 16;\r\n      break;\r\n    }\r\n    if(md === null) {\r\n      throw new Error('PKCS#12 uses unsupported MAC algorithm: ' + macAlgorithm);\r\n    }\r\n\r\n    // verify MAC (iterations default to 1)\r\n    var macSalt = new forge.util.ByteBuffer(capture.macSalt);\r\n    var macIterations = (('macIterations' in capture) ?\r\n      parseInt(forge.util.bytesToHex(capture.macIterations), 16) : 1);\r\n    var macKey = p12.generateKey(\r\n      password, macSalt, 3, macIterations, macKeyBytes, md);\r\n    var mac = forge.hmac.create();\r\n    mac.start(md, macKey);\r\n    mac.update(data.value);\r\n    var macValue = mac.getMac();\r\n    if(macValue.getBytes() !== capture.macDigest) {\r\n      throw new Error('PKCS#12 MAC could not be verified. Invalid password?');\r\n    }\r\n  }\r\n\r\n  _decodeAuthenticatedSafe(pfx, data.value, strict, password);\r\n  return pfx;\r\n};\r\n\r\n/**\r\n * Decodes PKCS#7 Data. PKCS#7 (RFC 2315) defines \"Data\" as an OCTET STRING,\r\n * but it is sometimes an OCTET STRING that is composed/constructed of chunks,\r\n * each its own OCTET STRING. This is BER-encoding vs. DER-encoding. This\r\n * function transforms this corner-case into the usual simple,\r\n * non-composed/constructed OCTET STRING.\r\n *\r\n * This function may be moved to ASN.1 at some point to better deal with\r\n * more BER-encoding issues, should they arise.\r\n *\r\n * @param data the ASN.1 Data object to transform.\r\n */\r\nfunction _decodePkcs7Data(data) {\r\n  // handle special case of \"chunked\" data content: an octet string composed\r\n  // of other octet strings\r\n  if(data.composed || data.constructed) {\r\n    var value = forge.util.createBuffer();\r\n    for(var i = 0; i < data.value.length; ++i) {\r\n      value.putBytes(data.value[i].value);\r\n    }\r\n    data.composed = data.constructed = false;\r\n    data.value = value.getBytes();\r\n  }\r\n  return data;\r\n}\r\n\r\n/**\r\n * Decode PKCS#12 AuthenticatedSafe (BER encoded) into PFX object.\r\n *\r\n * The AuthenticatedSafe is a BER-encoded SEQUENCE OF ContentInfo.\r\n *\r\n * @param pfx The PKCS#12 PFX object to fill.\r\n * @param {String} authSafe BER-encoded AuthenticatedSafe.\r\n * @param strict true to use strict DER decoding, false not to.\r\n * @param {String} password Password to decrypt with (optional).\r\n */\r\nfunction _decodeAuthenticatedSafe(pfx, authSafe, strict, password) {\r\n  authSafe = asn1.fromDer(authSafe, strict);  /* actually it's BER encoded */\r\n\r\n  if(authSafe.tagClass !== asn1.Class.UNIVERSAL ||\r\n     authSafe.type !== asn1.Type.SEQUENCE ||\r\n     authSafe.constructed !== true) {\r\n    throw new Error('PKCS#12 AuthenticatedSafe expected to be a ' +\r\n      'SEQUENCE OF ContentInfo');\r\n  }\r\n\r\n  for(var i = 0; i < authSafe.value.length; i++) {\r\n    var contentInfo = authSafe.value[i];\r\n\r\n    // validate contentInfo and capture data\r\n    var capture = {};\r\n    var errors = [];\r\n    if(!asn1.validate(contentInfo, contentInfoValidator, capture, errors)) {\r\n      var error = new Error('Cannot read ContentInfo.');\r\n      error.errors = errors;\r\n      throw error;\r\n    }\r\n\r\n    var obj = {\r\n      encrypted: false\r\n    };\r\n    var safeContents = null;\r\n    var data = capture.content.value[0];\r\n    switch(asn1.derToOid(capture.contentType)) {\r\n    case pki.oids.data:\r\n      if(data.tagClass !== asn1.Class.UNIVERSAL ||\r\n         data.type !== asn1.Type.OCTETSTRING) {\r\n        throw new Error('PKCS#12 SafeContents Data is not an OCTET STRING.');\r\n      }\r\n      safeContents = _decodePkcs7Data(data).value;\r\n      break;\r\n    case pki.oids.encryptedData:\r\n      safeContents = _decryptSafeContents(data, password);\r\n      obj.encrypted = true;\r\n      break;\r\n    default:\r\n      var error = new Error('Unsupported PKCS#12 contentType.');\r\n      error.contentType = asn1.derToOid(capture.contentType);\r\n      throw error;\r\n    }\r\n\r\n    obj.safeBags = _decodeSafeContents(safeContents, strict, password);\r\n    pfx.safeContents.push(obj);\r\n  }\r\n}\r\n\r\n/**\r\n * Decrypt PKCS#7 EncryptedData structure.\r\n *\r\n * @param data ASN.1 encoded EncryptedContentInfo object.\r\n * @param password The user-provided password.\r\n *\r\n * @return The decrypted SafeContents (ASN.1 object).\r\n */\r\nfunction _decryptSafeContents(data, password) {\r\n  var capture = {};\r\n  var errors = [];\r\n  if(!asn1.validate(\r\n    data, forge.pkcs7.asn1.encryptedDataValidator, capture, errors)) {\r\n    var error = new Error('Cannot read EncryptedContentInfo.');\r\n    error.errors = errors;\r\n    throw error;\r\n  }\r\n\r\n  var oid = asn1.derToOid(capture.contentType);\r\n  if(oid !== pki.oids.data) {\r\n    var error = new Error(\r\n      'PKCS#12 EncryptedContentInfo ContentType is not Data.');\r\n    error.oid = oid;\r\n    throw error;\r\n  }\r\n\r\n  // get cipher\r\n  oid = asn1.derToOid(capture.encAlgorithm);\r\n  var cipher = pki.pbe.getCipher(oid, capture.encParameter, password);\r\n\r\n  // get encrypted data\r\n  var encryptedContentAsn1 = _decodePkcs7Data(capture.encryptedContentAsn1);\r\n  var encrypted = forge.util.createBuffer(encryptedContentAsn1.value);\r\n\r\n  cipher.update(encrypted);\r\n  if(!cipher.finish()) {\r\n    throw new Error('Failed to decrypt PKCS#12 SafeContents.');\r\n  }\r\n\r\n  return cipher.output.getBytes();\r\n}\r\n\r\n/**\r\n * Decode PKCS#12 SafeContents (BER-encoded) into array of Bag objects.\r\n *\r\n * The safeContents is a BER-encoded SEQUENCE OF SafeBag.\r\n *\r\n * @param {String} safeContents BER-encoded safeContents.\r\n * @param strict true to use strict DER decoding, false not to.\r\n * @param {String} password Password to decrypt with (optional).\r\n *\r\n * @return {Array} Array of Bag objects.\r\n */\r\nfunction _decodeSafeContents(safeContents, strict, password) {\r\n  // if strict and no safe contents, return empty safes\r\n  if(!strict && safeContents.length === 0) {\r\n    return [];\r\n  }\r\n\r\n  // actually it's BER-encoded\r\n  safeContents = asn1.fromDer(safeContents, strict);\r\n\r\n  if(safeContents.tagClass !== asn1.Class.UNIVERSAL ||\r\n    safeContents.type !== asn1.Type.SEQUENCE ||\r\n    safeContents.constructed !== true) {\r\n    throw new Error(\r\n      'PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag.');\r\n  }\r\n\r\n  var res = [];\r\n  for(var i = 0; i < safeContents.value.length; i++) {\r\n    var safeBag = safeContents.value[i];\r\n\r\n    // validate SafeBag and capture data\r\n    var capture = {};\r\n    var errors = [];\r\n    if(!asn1.validate(safeBag, safeBagValidator, capture, errors)) {\r\n      var error = new Error('Cannot read SafeBag.');\r\n      error.errors = errors;\r\n      throw error;\r\n    }\r\n\r\n    /* Create bag object and push to result array. */\r\n    var bag = {\r\n      type: asn1.derToOid(capture.bagId),\r\n      attributes: _decodeBagAttributes(capture.bagAttributes)\r\n    };\r\n    res.push(bag);\r\n\r\n    var validator, decoder;\r\n    var bagAsn1 = capture.bagValue.value[0];\r\n    switch(bag.type) {\r\n      case pki.oids.pkcs8ShroudedKeyBag:\r\n        /* bagAsn1 has a EncryptedPrivateKeyInfo, which we need to decrypt.\r\n           Afterwards we can handle it like a keyBag,\r\n           which is a PrivateKeyInfo. */\r\n        bagAsn1 = pki.decryptPrivateKeyInfo(bagAsn1, password);\r\n        if(bagAsn1 === null) {\r\n          throw new Error(\r\n            'Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?');\r\n        }\r\n\r\n        /* fall through */\r\n      case pki.oids.keyBag:\r\n        /* A PKCS#12 keyBag is a simple PrivateKeyInfo as understood by our\r\n           PKI module, hence we don't have to do validation/capturing here,\r\n           just pass what we already got. */\r\n        try {\r\n          bag.key = pki.privateKeyFromAsn1(bagAsn1);\r\n        } catch(e) {\r\n          // ignore unknown key type, pass asn1 value\r\n          bag.key = null;\r\n          bag.asn1 = bagAsn1;\r\n        }\r\n        continue;  /* Nothing more to do. */\r\n\r\n      case pki.oids.certBag:\r\n        /* A PKCS#12 certBag can wrap both X.509 and sdsi certificates.\r\n           Therefore put the SafeBag content through another validator to\r\n           capture the fields.  Afterwards check & store the results. */\r\n        validator = certBagValidator;\r\n        decoder = function() {\r\n          if(asn1.derToOid(capture.certId) !== pki.oids.x509Certificate) {\r\n            var error = new Error(\r\n              'Unsupported certificate type, only X.509 supported.');\r\n            error.oid = asn1.derToOid(capture.certId);\r\n            throw error;\r\n          }\r\n\r\n          // true=produce cert hash\r\n          var certAsn1 = asn1.fromDer(capture.cert, strict);\r\n          try {\r\n            bag.cert = pki.certificateFromAsn1(certAsn1, true);\r\n          } catch(e) {\r\n            // ignore unknown cert type, pass asn1 value\r\n            bag.cert = null;\r\n            bag.asn1 = certAsn1;\r\n          }\r\n        };\r\n        break;\r\n\r\n      default:\r\n        var error = new Error('Unsupported PKCS#12 SafeBag type.');\r\n        error.oid = bag.type;\r\n        throw error;\r\n    }\r\n\r\n    /* Validate SafeBag value (i.e. CertBag, etc.) and capture data if needed. */\r\n    if(validator !== undefined &&\r\n       !asn1.validate(bagAsn1, validator, capture, errors)) {\r\n      var error = new Error('Cannot read PKCS#12 ' + validator.name);\r\n      error.errors = errors;\r\n      throw error;\r\n    }\r\n\r\n    /* Call decoder function from above to store the results. */\r\n    decoder();\r\n  }\r\n\r\n  return res;\r\n}\r\n\r\n/**\r\n * Decode PKCS#12 SET OF PKCS12Attribute into JavaScript object.\r\n *\r\n * @param attributes SET OF PKCS12Attribute (ASN.1 object).\r\n *\r\n * @return the decoded attributes.\r\n */\r\nfunction _decodeBagAttributes(attributes) {\r\n  var decodedAttrs = {};\r\n\r\n  if(attributes !== undefined) {\r\n    for(var i = 0; i < attributes.length; ++i) {\r\n      var capture = {};\r\n      var errors = [];\r\n      if(!asn1.validate(attributes[i], attributeValidator, capture, errors)) {\r\n        var error = new Error('Cannot read PKCS#12 BagAttribute.');\r\n        error.errors = errors;\r\n        throw error;\r\n      }\r\n\r\n      var oid = asn1.derToOid(capture.oid);\r\n      if(pki.oids[oid] === undefined) {\r\n        // unsupported attribute type, ignore.\r\n        continue;\r\n      }\r\n\r\n      decodedAttrs[pki.oids[oid]] = [];\r\n      for(var j = 0; j < capture.values.length; ++j) {\r\n        decodedAttrs[pki.oids[oid]].push(capture.values[j].value);\r\n      }\r\n    }\r\n  }\r\n\r\n  return decodedAttrs;\r\n}\r\n\r\n/**\r\n * Wraps a private key and certificate in a PKCS#12 PFX wrapper. If a\r\n * password is provided then the private key will be encrypted.\r\n *\r\n * An entire certificate chain may also be included. To do this, pass\r\n * an array for the \"cert\" parameter where the first certificate is\r\n * the one that is paired with the private key and each subsequent one\r\n * verifies the previous one. The certificates may be in PEM format or\r\n * have been already parsed by Forge.\r\n *\r\n * @todo implement password-based-encryption for the whole package\r\n *\r\n * @param key the private key.\r\n * @param cert the certificate (may be an array of certificates in order\r\n *          to specify a certificate chain).\r\n * @param password the password to use, null for none.\r\n * @param options:\r\n *          algorithm the encryption algorithm to use\r\n *            ('aes128', 'aes192', 'aes256', '3des'), defaults to 'aes128'.\r\n *          count the iteration count to use.\r\n *          saltSize the salt size to use.\r\n *          useMac true to include a MAC, false not to, defaults to true.\r\n *          localKeyId the local key ID to use, in hex.\r\n *          friendlyName the friendly name to use.\r\n *          generateLocalKeyId true to generate a random local key ID,\r\n *            false not to, defaults to true.\r\n *\r\n * @return the PKCS#12 PFX ASN.1 object.\r\n */\r\np12.toPkcs12Asn1 = function(key, cert, password, options) {\r\n  // set default options\r\n  options = options || {};\r\n  options.saltSize = options.saltSize || 8;\r\n  options.count = options.count || 2048;\r\n  options.algorithm = options.algorithm || options.encAlgorithm || 'aes128';\r\n  if(!('useMac' in options)) {\r\n    options.useMac = true;\r\n  }\r\n  if(!('localKeyId' in options)) {\r\n    options.localKeyId = null;\r\n  }\r\n  if(!('generateLocalKeyId' in options)) {\r\n    options.generateLocalKeyId = true;\r\n  }\r\n\r\n  var localKeyId = options.localKeyId;\r\n  var bagAttrs;\r\n  if(localKeyId !== null) {\r\n    localKeyId = forge.util.hexToBytes(localKeyId);\r\n  } else if(options.generateLocalKeyId) {\r\n    // use SHA-1 of paired cert, if available\r\n    if(cert) {\r\n      var pairedCert = forge.util.isArray(cert) ? cert[0] : cert;\r\n      if(typeof pairedCert === 'string') {\r\n        pairedCert = pki.certificateFromPem(pairedCert);\r\n      }\r\n      var sha1 = forge.md.sha1.create();\r\n      sha1.update(asn1.toDer(pki.certificateToAsn1(pairedCert)).getBytes());\r\n      localKeyId = sha1.digest().getBytes();\r\n    } else {\r\n      // FIXME: consider using SHA-1 of public key (which can be generated\r\n      // from private key components), see: cert.generateSubjectKeyIdentifier\r\n      // generate random bytes\r\n      localKeyId = forge.random.getBytes(20);\r\n    }\r\n  }\r\n\r\n  var attrs = [];\r\n  if(localKeyId !== null) {\r\n    attrs.push(\r\n      // localKeyID\r\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r\n        // attrId\r\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r\n          asn1.oidToDer(pki.oids.localKeyId).getBytes()),\r\n        // attrValues\r\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [\r\n          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,\r\n            localKeyId)\r\n        ])\r\n      ]));\r\n  }\r\n  if('friendlyName' in options) {\r\n    attrs.push(\r\n      // friendlyName\r\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r\n        // attrId\r\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r\n          asn1.oidToDer(pki.oids.friendlyName).getBytes()),\r\n        // attrValues\r\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [\r\n          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BMPSTRING, false,\r\n            options.friendlyName)\r\n        ])\r\n      ]));\r\n  }\r\n\r\n  if(attrs.length > 0) {\r\n    bagAttrs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, attrs);\r\n  }\r\n\r\n  // collect contents for AuthenticatedSafe\r\n  var contents = [];\r\n\r\n  // create safe bag(s) for certificate chain\r\n  var chain = [];\r\n  if(cert !== null) {\r\n    if(forge.util.isArray(cert)) {\r\n      chain = cert;\r\n    } else {\r\n      chain = [cert];\r\n    }\r\n  }\r\n\r\n  var certSafeBags = [];\r\n  for(var i = 0; i < chain.length; ++i) {\r\n    // convert cert from PEM as necessary\r\n    cert = chain[i];\r\n    if(typeof cert === 'string') {\r\n      cert = pki.certificateFromPem(cert);\r\n    }\r\n\r\n    // SafeBag\r\n    var certBagAttrs = (i === 0) ? bagAttrs : undefined;\r\n    var certAsn1 = pki.certificateToAsn1(cert);\r\n    var certSafeBag =\r\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r\n        // bagId\r\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r\n          asn1.oidToDer(pki.oids.certBag).getBytes()),\r\n        // bagValue\r\n        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\r\n          // CertBag\r\n          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r\n            // certId\r\n            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r\n              asn1.oidToDer(pki.oids.x509Certificate).getBytes()),\r\n            // certValue (x509Certificate)\r\n            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\r\n              asn1.create(\r\n                asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,\r\n                asn1.toDer(certAsn1).getBytes())\r\n            ])])]),\r\n        // bagAttributes (OPTIONAL)\r\n        certBagAttrs\r\n      ]);\r\n    certSafeBags.push(certSafeBag);\r\n  }\r\n\r\n  if(certSafeBags.length > 0) {\r\n    // SafeContents\r\n    var certSafeContents = asn1.create(\r\n      asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, certSafeBags);\r\n\r\n    // ContentInfo\r\n    var certCI =\r\n      // PKCS#7 ContentInfo\r\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r\n        // contentType\r\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r\n          // OID for the content type is 'data'\r\n          asn1.oidToDer(pki.oids.data).getBytes()),\r\n        // content\r\n        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\r\n          asn1.create(\r\n            asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,\r\n            asn1.toDer(certSafeContents).getBytes())\r\n        ])\r\n      ]);\r\n    contents.push(certCI);\r\n  }\r\n\r\n  // create safe contents for private key\r\n  var keyBag = null;\r\n  if(key !== null) {\r\n    // SafeBag\r\n    var pkAsn1 = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(key));\r\n    if(password === null) {\r\n      // no encryption\r\n      keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r\n        // bagId\r\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r\n          asn1.oidToDer(pki.oids.keyBag).getBytes()),\r\n        // bagValue\r\n        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\r\n          // PrivateKeyInfo\r\n          pkAsn1\r\n        ]),\r\n        // bagAttributes (OPTIONAL)\r\n        bagAttrs\r\n      ]);\r\n    } else {\r\n      // encrypted PrivateKeyInfo\r\n      keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r\n        // bagId\r\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r\n          asn1.oidToDer(pki.oids.pkcs8ShroudedKeyBag).getBytes()),\r\n        // bagValue\r\n        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\r\n          // EncryptedPrivateKeyInfo\r\n          pki.encryptPrivateKeyInfo(pkAsn1, password, options)\r\n        ]),\r\n        // bagAttributes (OPTIONAL)\r\n        bagAttrs\r\n      ]);\r\n    }\r\n\r\n    // SafeContents\r\n    var keySafeContents =\r\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [keyBag]);\r\n\r\n    // ContentInfo\r\n    var keyCI =\r\n      // PKCS#7 ContentInfo\r\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r\n        // contentType\r\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r\n          // OID for the content type is 'data'\r\n          asn1.oidToDer(pki.oids.data).getBytes()),\r\n        // content\r\n        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\r\n          asn1.create(\r\n            asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,\r\n            asn1.toDer(keySafeContents).getBytes())\r\n        ])\r\n      ]);\r\n    contents.push(keyCI);\r\n  }\r\n\r\n  // create AuthenticatedSafe by stringing together the contents\r\n  var safe = asn1.create(\r\n    asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, contents);\r\n\r\n  var macData;\r\n  if(options.useMac) {\r\n    // MacData\r\n    var sha1 = forge.md.sha1.create();\r\n    var macSalt = new forge.util.ByteBuffer(\r\n      forge.random.getBytes(options.saltSize));\r\n    var count = options.count;\r\n    // 160-bit key\r\n    var key = p12.generateKey(password, macSalt, 3, count, 20);\r\n    var mac = forge.hmac.create();\r\n    mac.start(sha1, key);\r\n    mac.update(asn1.toDer(safe).getBytes());\r\n    var macValue = mac.getMac();\r\n    macData = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r\n      // mac DigestInfo\r\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r\n        // digestAlgorithm\r\n        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r\n          // algorithm = SHA-1\r\n          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r\n            asn1.oidToDer(pki.oids.sha1).getBytes()),\r\n          // parameters = Null\r\n          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')\r\n        ]),\r\n        // digest\r\n        asn1.create(\r\n          asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING,\r\n          false, macValue.getBytes())\r\n      ]),\r\n      // macSalt OCTET STRING\r\n      asn1.create(\r\n        asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, macSalt.getBytes()),\r\n      // iterations INTEGER (XXX: Only support count < 65536)\r\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r\n        asn1.integerToDer(count).getBytes()\r\n      )\r\n    ]);\r\n  }\r\n\r\n  // PFX\r\n  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r\n    // version (3)\r\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\r\n      asn1.integerToDer(3).getBytes()),\r\n    // PKCS#7 ContentInfo\r\n    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\r\n      // contentType\r\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false,\r\n        // OID for the content type is 'data'\r\n        asn1.oidToDer(pki.oids.data).getBytes()),\r\n      // content\r\n      asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [\r\n        asn1.create(\r\n          asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,\r\n          asn1.toDer(safe).getBytes())\r\n      ])\r\n    ]),\r\n    macData\r\n  ]);\r\n};\r\n\r\n/**\r\n * Derives a PKCS#12 key.\r\n *\r\n * @param password the password to derive the key material from, null or\r\n *          undefined for none.\r\n * @param salt the salt, as a ByteBuffer, to use.\r\n * @param id the PKCS#12 ID byte (1 = key material, 2 = IV, 3 = MAC).\r\n * @param iter the iteration count.\r\n * @param n the number of bytes to derive from the password.\r\n * @param md the message digest to use, defaults to SHA-1.\r\n *\r\n * @return a ByteBuffer with the bytes derived from the password.\r\n */\r\np12.generateKey = forge.pbe.generatePkcs12Key;\r\n"]},"metadata":{},"sourceType":"script"}