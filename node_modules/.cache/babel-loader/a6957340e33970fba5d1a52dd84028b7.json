{"ast":null,"code":"\"use strict\"; // Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nvar _a, _b, _c;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.IdentityPoolClient = void 0;\n\nconst fs = require(\"fs\");\n\nconst util_1 = require(\"util\");\n\nconst baseexternalclient_1 = require(\"./baseexternalclient\"); // fs.readfile is undefined in browser karma tests causing\n// `npm run browser-test` to fail as test.oauth2.ts imports this file via\n// src/index.ts.\n// Fallback to void function to avoid promisify throwing a TypeError.\n\n\nconst readFile = util_1.promisify((_a = fs.readFile) !== null && _a !== void 0 ? _a : () => {});\nconst realpath = util_1.promisify((_b = fs.realpath) !== null && _b !== void 0 ? _b : () => {});\nconst lstat = util_1.promisify((_c = fs.lstat) !== null && _c !== void 0 ? _c : () => {});\n/**\r\n * Defines the Url-sourced and file-sourced external account clients mainly\r\n * used for K8s and Azure workloads.\r\n */\n\nclass IdentityPoolClient extends baseexternalclient_1.BaseExternalAccountClient {\n  /**\r\n   * Instantiate an IdentityPoolClient instance using the provided JSON\r\n   * object loaded from an external account credentials file.\r\n   * An error is thrown if the credential is not a valid file-sourced or\r\n   * url-sourced credential.\r\n   * @param options The external account options object typically loaded\r\n   *   from the external account JSON credential file.\r\n   * @param additionalOptions Optional additional behavior customization\r\n   *   options. These currently customize expiration threshold time and\r\n   *   whether to retry on 401/403 API request errors.\r\n   */\n  constructor(options, additionalOptions) {\n    var _a, _b;\n\n    super(options, additionalOptions);\n    this.file = options.credential_source.file;\n    this.url = options.credential_source.url;\n    this.headers = options.credential_source.headers;\n\n    if (!this.file && !this.url) {\n      throw new Error('No valid Identity Pool \"credential_source\" provided');\n    } // Text is the default format type.\n\n\n    this.formatType = ((_a = options.credential_source.format) === null || _a === void 0 ? void 0 : _a.type) || 'text';\n    this.formatSubjectTokenFieldName = (_b = options.credential_source.format) === null || _b === void 0 ? void 0 : _b.subject_token_field_name;\n\n    if (this.formatType !== 'json' && this.formatType !== 'text') {\n      throw new Error(`Invalid credential_source format \"${this.formatType}\"`);\n    }\n\n    if (this.formatType === 'json' && !this.formatSubjectTokenFieldName) {\n      throw new Error('Missing subject_token_field_name for JSON credential_source format');\n    }\n  }\n  /**\r\n   * Triggered when a external subject token is needed to be exchanged for a GCP\r\n   * access token via GCP STS endpoint.\r\n   * This uses the `options.credential_source` object to figure out how\r\n   * to retrieve the token using the current environment. In this case,\r\n   * this either retrieves the local credential from a file location (k8s\r\n   * workload) or by sending a GET request to a local metadata server (Azure\r\n   * workloads).\r\n   * @return A promise that resolves with the external subject token.\r\n   */\n\n\n  async retrieveSubjectToken() {\n    if (this.file) {\n      return await this.getTokenFromFile(this.file, this.formatType, this.formatSubjectTokenFieldName);\n    }\n\n    return await this.getTokenFromUrl(this.url, this.formatType, this.formatSubjectTokenFieldName, this.headers);\n  }\n  /**\r\n   * Looks up the external subject token in the file path provided and\r\n   * resolves with that token.\r\n   * @param file The file path where the external credential is located.\r\n   * @param formatType The token file or URL response type (JSON or text).\r\n   * @param formatSubjectTokenFieldName For JSON response types, this is the\r\n   *   subject_token field name. For Azure, this is access_token. For text\r\n   *   response types, this is ignored.\r\n   * @return A promise that resolves with the external subject token.\r\n   */\n\n\n  async getTokenFromFile(filePath, formatType, formatSubjectTokenFieldName) {\n    // Make sure there is a file at the path. lstatSync will throw if there is\n    // nothing there.\n    try {\n      // Resolve path to actual file in case of symlink. Expect a thrown error\n      // if not resolvable.\n      filePath = await realpath(filePath);\n\n      if (!(await lstat(filePath)).isFile()) {\n        throw new Error();\n      }\n    } catch (err) {\n      err.message = `The file at ${filePath} does not exist, or it is not a file. ${err.message}`;\n      throw err;\n    }\n\n    let subjectToken;\n    const rawText = await readFile(filePath, {\n      encoding: 'utf8'\n    });\n\n    if (formatType === 'text') {\n      subjectToken = rawText;\n    } else if (formatType === 'json' && formatSubjectTokenFieldName) {\n      const json = JSON.parse(rawText);\n      subjectToken = json[formatSubjectTokenFieldName];\n    }\n\n    if (!subjectToken) {\n      throw new Error('Unable to parse the subject_token from the credential_source file');\n    }\n\n    return subjectToken;\n  }\n  /**\r\n   * Sends a GET request to the URL provided and resolves with the returned\r\n   * external subject token.\r\n   * @param url The URL to call to retrieve the subject token. This is typically\r\n   *   a local metadata server.\r\n   * @param formatType The token file or URL response type (JSON or text).\r\n   * @param formatSubjectTokenFieldName For JSON response types, this is the\r\n   *   subject_token field name. For Azure, this is access_token. For text\r\n   *   response types, this is ignored.\r\n   * @param headers The optional additional headers to send with the request to\r\n   *   the metadata server url.\r\n   * @return A promise that resolves with the external subject token.\r\n   */\n\n\n  async getTokenFromUrl(url, formatType, formatSubjectTokenFieldName, headers) {\n    const opts = {\n      url,\n      method: 'GET',\n      headers,\n      responseType: formatType\n    };\n    let subjectToken;\n\n    if (formatType === 'text') {\n      const response = await this.transporter.request(opts);\n      subjectToken = response.data;\n    } else if (formatType === 'json' && formatSubjectTokenFieldName) {\n      const response = await this.transporter.request(opts);\n      subjectToken = response.data[formatSubjectTokenFieldName];\n    }\n\n    if (!subjectToken) {\n      throw new Error('Unable to parse the subject_token from the credential_source URL');\n    }\n\n    return subjectToken;\n  }\n\n}\n\nexports.IdentityPoolClient = IdentityPoolClient;","map":{"version":3,"sources":["C:/Users/ibott/MajorGroupProject/node_modules/google-auth-library/build/src/auth/identitypoolclient.js"],"names":["_a","_b","_c","Object","defineProperty","exports","value","IdentityPoolClient","fs","require","util_1","baseexternalclient_1","readFile","promisify","realpath","lstat","BaseExternalAccountClient","constructor","options","additionalOptions","file","credential_source","url","headers","Error","formatType","format","type","formatSubjectTokenFieldName","subject_token_field_name","retrieveSubjectToken","getTokenFromFile","getTokenFromUrl","filePath","isFile","err","message","subjectToken","rawText","encoding","json","JSON","parse","opts","method","responseType","response","transporter","request","data"],"mappings":"AAAA,a,CACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIA,EAAJ,EAAQC,EAAR,EAAYC,EAAZ;;AACAC,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,kBAAR,GAA6B,KAAK,CAAlC;;AACA,MAAMC,EAAE,GAAGC,OAAO,CAAC,IAAD,CAAlB;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,MAAD,CAAtB;;AACA,MAAME,oBAAoB,GAAGF,OAAO,CAAC,sBAAD,CAApC,C,CACA;AACA;AACA;AACA;;;AACA,MAAMG,QAAQ,GAAGF,MAAM,CAACG,SAAP,CAAiB,CAACb,EAAE,GAAGQ,EAAE,CAACI,QAAT,MAAuB,IAAvB,IAA+BZ,EAAE,KAAK,KAAK,CAA3C,GAA+CA,EAA/C,GAAqD,MAAM,CAAG,CAA/E,CAAjB;AACA,MAAMc,QAAQ,GAAGJ,MAAM,CAACG,SAAP,CAAiB,CAACZ,EAAE,GAAGO,EAAE,CAACM,QAAT,MAAuB,IAAvB,IAA+Bb,EAAE,KAAK,KAAK,CAA3C,GAA+CA,EAA/C,GAAqD,MAAM,CAAG,CAA/E,CAAjB;AACA,MAAMc,KAAK,GAAGL,MAAM,CAACG,SAAP,CAAiB,CAACX,EAAE,GAAGM,EAAE,CAACO,KAAT,MAAoB,IAApB,IAA4Bb,EAAE,KAAK,KAAK,CAAxC,GAA4CA,EAA5C,GAAkD,MAAM,CAAG,CAA5E,CAAd;AACA;AACA;AACA;AACA;;AACA,MAAMK,kBAAN,SAAiCI,oBAAoB,CAACK,yBAAtD,CAAgF;AAC5E;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACIC,EAAAA,WAAW,CAACC,OAAD,EAAUC,iBAAV,EAA6B;AACpC,QAAInB,EAAJ,EAAQC,EAAR;;AACA,UAAMiB,OAAN,EAAeC,iBAAf;AACA,SAAKC,IAAL,GAAYF,OAAO,CAACG,iBAAR,CAA0BD,IAAtC;AACA,SAAKE,GAAL,GAAWJ,OAAO,CAACG,iBAAR,CAA0BC,GAArC;AACA,SAAKC,OAAL,GAAeL,OAAO,CAACG,iBAAR,CAA0BE,OAAzC;;AACA,QAAI,CAAC,KAAKH,IAAN,IAAc,CAAC,KAAKE,GAAxB,EAA6B;AACzB,YAAM,IAAIE,KAAJ,CAAU,qDAAV,CAAN;AACH,KARmC,CASpC;;;AACA,SAAKC,UAAL,GAAkB,CAAC,CAACzB,EAAE,GAAGkB,OAAO,CAACG,iBAAR,CAA0BK,MAAhC,MAA4C,IAA5C,IAAoD1B,EAAE,KAAK,KAAK,CAAhE,GAAoE,KAAK,CAAzE,GAA6EA,EAAE,CAAC2B,IAAjF,KAA0F,MAA5G;AACA,SAAKC,2BAAL,GAAmC,CAAC3B,EAAE,GAAGiB,OAAO,CAACG,iBAAR,CAA0BK,MAAhC,MAA4C,IAA5C,IAAoDzB,EAAE,KAAK,KAAK,CAAhE,GAAoE,KAAK,CAAzE,GAA6EA,EAAE,CAAC4B,wBAAnH;;AACA,QAAI,KAAKJ,UAAL,KAAoB,MAApB,IAA8B,KAAKA,UAAL,KAAoB,MAAtD,EAA8D;AAC1D,YAAM,IAAID,KAAJ,CAAW,qCAAoC,KAAKC,UAAW,GAA/D,CAAN;AACH;;AACD,QAAI,KAAKA,UAAL,KAAoB,MAApB,IAA8B,CAAC,KAAKG,2BAAxC,EAAqE;AACjE,YAAM,IAAIJ,KAAJ,CAAU,oEAAV,CAAN;AACH;AACJ;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAC8B,QAApBM,oBAAoB,GAAG;AACzB,QAAI,KAAKV,IAAT,EAAe;AACX,aAAO,MAAM,KAAKW,gBAAL,CAAsB,KAAKX,IAA3B,EAAiC,KAAKK,UAAtC,EAAkD,KAAKG,2BAAvD,CAAb;AACH;;AACD,WAAO,MAAM,KAAKI,eAAL,CAAqB,KAAKV,GAA1B,EAA+B,KAAKG,UAApC,EAAgD,KAAKG,2BAArD,EAAkF,KAAKL,OAAvF,CAAb;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAC0B,QAAhBQ,gBAAgB,CAACE,QAAD,EAAWR,UAAX,EAAuBG,2BAAvB,EAAoD;AACtE;AACA;AACA,QAAI;AACA;AACA;AACAK,MAAAA,QAAQ,GAAG,MAAMnB,QAAQ,CAACmB,QAAD,CAAzB;;AACA,UAAI,CAAC,CAAC,MAAMlB,KAAK,CAACkB,QAAD,CAAZ,EAAwBC,MAAxB,EAAL,EAAuC;AACnC,cAAM,IAAIV,KAAJ,EAAN;AACH;AACJ,KAPD,CAQA,OAAOW,GAAP,EAAY;AACRA,MAAAA,GAAG,CAACC,OAAJ,GAAe,eAAcH,QAAS,yCAAwCE,GAAG,CAACC,OAAQ,EAA1F;AACA,YAAMD,GAAN;AACH;;AACD,QAAIE,YAAJ;AACA,UAAMC,OAAO,GAAG,MAAM1B,QAAQ,CAACqB,QAAD,EAAW;AAAEM,MAAAA,QAAQ,EAAE;AAAZ,KAAX,CAA9B;;AACA,QAAId,UAAU,KAAK,MAAnB,EAA2B;AACvBY,MAAAA,YAAY,GAAGC,OAAf;AACH,KAFD,MAGK,IAAIb,UAAU,KAAK,MAAf,IAAyBG,2BAA7B,EAA0D;AAC3D,YAAMY,IAAI,GAAGC,IAAI,CAACC,KAAL,CAAWJ,OAAX,CAAb;AACAD,MAAAA,YAAY,GAAGG,IAAI,CAACZ,2BAAD,CAAnB;AACH;;AACD,QAAI,CAACS,YAAL,EAAmB;AACf,YAAM,IAAIb,KAAJ,CAAU,mEAAV,CAAN;AACH;;AACD,WAAOa,YAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACyB,QAAfL,eAAe,CAACV,GAAD,EAAMG,UAAN,EAAkBG,2BAAlB,EAA+CL,OAA/C,EAAwD;AACzE,UAAMoB,IAAI,GAAG;AACTrB,MAAAA,GADS;AAETsB,MAAAA,MAAM,EAAE,KAFC;AAGTrB,MAAAA,OAHS;AAITsB,MAAAA,YAAY,EAAEpB;AAJL,KAAb;AAMA,QAAIY,YAAJ;;AACA,QAAIZ,UAAU,KAAK,MAAnB,EAA2B;AACvB,YAAMqB,QAAQ,GAAG,MAAM,KAAKC,WAAL,CAAiBC,OAAjB,CAAyBL,IAAzB,CAAvB;AACAN,MAAAA,YAAY,GAAGS,QAAQ,CAACG,IAAxB;AACH,KAHD,MAIK,IAAIxB,UAAU,KAAK,MAAf,IAAyBG,2BAA7B,EAA0D;AAC3D,YAAMkB,QAAQ,GAAG,MAAM,KAAKC,WAAL,CAAiBC,OAAjB,CAAyBL,IAAzB,CAAvB;AACAN,MAAAA,YAAY,GAAGS,QAAQ,CAACG,IAAT,CAAcrB,2BAAd,CAAf;AACH;;AACD,QAAI,CAACS,YAAL,EAAmB;AACf,YAAM,IAAIb,KAAJ,CAAU,kEAAV,CAAN;AACH;;AACD,WAAOa,YAAP;AACH;;AAvH2E;;AAyHhFhC,OAAO,CAACE,kBAAR,GAA6BA,kBAA7B","sourcesContent":["\"use strict\";\r\n// Copyright 2021 Google LLC\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\nvar _a, _b, _c;\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.IdentityPoolClient = void 0;\r\nconst fs = require(\"fs\");\r\nconst util_1 = require(\"util\");\r\nconst baseexternalclient_1 = require(\"./baseexternalclient\");\r\n// fs.readfile is undefined in browser karma tests causing\r\n// `npm run browser-test` to fail as test.oauth2.ts imports this file via\r\n// src/index.ts.\r\n// Fallback to void function to avoid promisify throwing a TypeError.\r\nconst readFile = util_1.promisify((_a = fs.readFile) !== null && _a !== void 0 ? _a : (() => { }));\r\nconst realpath = util_1.promisify((_b = fs.realpath) !== null && _b !== void 0 ? _b : (() => { }));\r\nconst lstat = util_1.promisify((_c = fs.lstat) !== null && _c !== void 0 ? _c : (() => { }));\r\n/**\r\n * Defines the Url-sourced and file-sourced external account clients mainly\r\n * used for K8s and Azure workloads.\r\n */\r\nclass IdentityPoolClient extends baseexternalclient_1.BaseExternalAccountClient {\r\n    /**\r\n     * Instantiate an IdentityPoolClient instance using the provided JSON\r\n     * object loaded from an external account credentials file.\r\n     * An error is thrown if the credential is not a valid file-sourced or\r\n     * url-sourced credential.\r\n     * @param options The external account options object typically loaded\r\n     *   from the external account JSON credential file.\r\n     * @param additionalOptions Optional additional behavior customization\r\n     *   options. These currently customize expiration threshold time and\r\n     *   whether to retry on 401/403 API request errors.\r\n     */\r\n    constructor(options, additionalOptions) {\r\n        var _a, _b;\r\n        super(options, additionalOptions);\r\n        this.file = options.credential_source.file;\r\n        this.url = options.credential_source.url;\r\n        this.headers = options.credential_source.headers;\r\n        if (!this.file && !this.url) {\r\n            throw new Error('No valid Identity Pool \"credential_source\" provided');\r\n        }\r\n        // Text is the default format type.\r\n        this.formatType = ((_a = options.credential_source.format) === null || _a === void 0 ? void 0 : _a.type) || 'text';\r\n        this.formatSubjectTokenFieldName = (_b = options.credential_source.format) === null || _b === void 0 ? void 0 : _b.subject_token_field_name;\r\n        if (this.formatType !== 'json' && this.formatType !== 'text') {\r\n            throw new Error(`Invalid credential_source format \"${this.formatType}\"`);\r\n        }\r\n        if (this.formatType === 'json' && !this.formatSubjectTokenFieldName) {\r\n            throw new Error('Missing subject_token_field_name for JSON credential_source format');\r\n        }\r\n    }\r\n    /**\r\n     * Triggered when a external subject token is needed to be exchanged for a GCP\r\n     * access token via GCP STS endpoint.\r\n     * This uses the `options.credential_source` object to figure out how\r\n     * to retrieve the token using the current environment. In this case,\r\n     * this either retrieves the local credential from a file location (k8s\r\n     * workload) or by sending a GET request to a local metadata server (Azure\r\n     * workloads).\r\n     * @return A promise that resolves with the external subject token.\r\n     */\r\n    async retrieveSubjectToken() {\r\n        if (this.file) {\r\n            return await this.getTokenFromFile(this.file, this.formatType, this.formatSubjectTokenFieldName);\r\n        }\r\n        return await this.getTokenFromUrl(this.url, this.formatType, this.formatSubjectTokenFieldName, this.headers);\r\n    }\r\n    /**\r\n     * Looks up the external subject token in the file path provided and\r\n     * resolves with that token.\r\n     * @param file The file path where the external credential is located.\r\n     * @param formatType The token file or URL response type (JSON or text).\r\n     * @param formatSubjectTokenFieldName For JSON response types, this is the\r\n     *   subject_token field name. For Azure, this is access_token. For text\r\n     *   response types, this is ignored.\r\n     * @return A promise that resolves with the external subject token.\r\n     */\r\n    async getTokenFromFile(filePath, formatType, formatSubjectTokenFieldName) {\r\n        // Make sure there is a file at the path. lstatSync will throw if there is\r\n        // nothing there.\r\n        try {\r\n            // Resolve path to actual file in case of symlink. Expect a thrown error\r\n            // if not resolvable.\r\n            filePath = await realpath(filePath);\r\n            if (!(await lstat(filePath)).isFile()) {\r\n                throw new Error();\r\n            }\r\n        }\r\n        catch (err) {\r\n            err.message = `The file at ${filePath} does not exist, or it is not a file. ${err.message}`;\r\n            throw err;\r\n        }\r\n        let subjectToken;\r\n        const rawText = await readFile(filePath, { encoding: 'utf8' });\r\n        if (formatType === 'text') {\r\n            subjectToken = rawText;\r\n        }\r\n        else if (formatType === 'json' && formatSubjectTokenFieldName) {\r\n            const json = JSON.parse(rawText);\r\n            subjectToken = json[formatSubjectTokenFieldName];\r\n        }\r\n        if (!subjectToken) {\r\n            throw new Error('Unable to parse the subject_token from the credential_source file');\r\n        }\r\n        return subjectToken;\r\n    }\r\n    /**\r\n     * Sends a GET request to the URL provided and resolves with the returned\r\n     * external subject token.\r\n     * @param url The URL to call to retrieve the subject token. This is typically\r\n     *   a local metadata server.\r\n     * @param formatType The token file or URL response type (JSON or text).\r\n     * @param formatSubjectTokenFieldName For JSON response types, this is the\r\n     *   subject_token field name. For Azure, this is access_token. For text\r\n     *   response types, this is ignored.\r\n     * @param headers The optional additional headers to send with the request to\r\n     *   the metadata server url.\r\n     * @return A promise that resolves with the external subject token.\r\n     */\r\n    async getTokenFromUrl(url, formatType, formatSubjectTokenFieldName, headers) {\r\n        const opts = {\r\n            url,\r\n            method: 'GET',\r\n            headers,\r\n            responseType: formatType,\r\n        };\r\n        let subjectToken;\r\n        if (formatType === 'text') {\r\n            const response = await this.transporter.request(opts);\r\n            subjectToken = response.data;\r\n        }\r\n        else if (formatType === 'json' && formatSubjectTokenFieldName) {\r\n            const response = await this.transporter.request(opts);\r\n            subjectToken = response.data[formatSubjectTokenFieldName];\r\n        }\r\n        if (!subjectToken) {\r\n            throw new Error('Unable to parse the subject_token from the credential_source URL');\r\n        }\r\n        return subjectToken;\r\n    }\r\n}\r\nexports.IdentityPoolClient = IdentityPoolClient;\r\n//# sourceMappingURL=identitypoolclient.js.map"]},"metadata":{},"sourceType":"script"}