{"ast":null,"code":"/**\r\n * Javascript implementation of mask generation function MGF1.\r\n *\r\n * @author Stefan Siegl\r\n * @author Dave Longley\r\n *\r\n * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>\r\n * Copyright (c) 2014 Digital Bazaar, Inc.\r\n */\nvar forge = require('./forge');\n\nrequire('./util');\n\nforge.mgf = forge.mgf || {};\nvar mgf1 = module.exports = forge.mgf.mgf1 = forge.mgf1 = forge.mgf1 || {};\n/**\r\n * Creates a MGF1 mask generation function object.\r\n *\r\n * @param md the message digest API to use (eg: forge.md.sha1.create()).\r\n *\r\n * @return a mask generation function object.\r\n */\n\nmgf1.create = function (md) {\n  var mgf = {\n    /**\r\n     * Generate mask of specified length.\r\n     *\r\n     * @param {String} seed The seed for mask generation.\r\n     * @param maskLen Number of bytes to generate.\r\n     * @return {String} The generated mask.\r\n     */\n    generate: function (seed, maskLen) {\n      /* 2. Let T be the empty octet string. */\n      var t = new forge.util.ByteBuffer();\n      /* 3. For counter from 0 to ceil(maskLen / hLen), do the following: */\n\n      var len = Math.ceil(maskLen / md.digestLength);\n\n      for (var i = 0; i < len; i++) {\n        /* a. Convert counter to an octet string C of length 4 octets */\n        var c = new forge.util.ByteBuffer();\n        c.putInt32(i);\n        /* b. Concatenate the hash of the seed mgfSeed and C to the octet\r\n         * string T: */\n\n        md.start();\n        md.update(seed + c.getBytes());\n        t.putBuffer(md.digest());\n      }\n      /* Output the leading maskLen octets of T as the octet string mask. */\n\n\n      t.truncate(t.length() - maskLen);\n      return t.getBytes();\n    }\n  };\n  return mgf;\n};","map":{"version":3,"sources":["C:/Users/ibott/MajorGroupProject/node_modules/node-forge/lib/mgf1.js"],"names":["forge","require","mgf","mgf1","module","exports","create","md","generate","seed","maskLen","t","util","ByteBuffer","len","Math","ceil","digestLength","i","c","putInt32","start","update","getBytes","putBuffer","digest","truncate","length"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIA,KAAK,GAAGC,OAAO,CAAC,SAAD,CAAnB;;AACAA,OAAO,CAAC,QAAD,CAAP;;AAEAD,KAAK,CAACE,GAAN,GAAYF,KAAK,CAACE,GAAN,IAAa,EAAzB;AACA,IAAIC,IAAI,GAAGC,MAAM,CAACC,OAAP,GAAiBL,KAAK,CAACE,GAAN,CAAUC,IAAV,GAAiBH,KAAK,CAACG,IAAN,GAAaH,KAAK,CAACG,IAAN,IAAc,EAAxE;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAA,IAAI,CAACG,MAAL,GAAc,UAASC,EAAT,EAAa;AACzB,MAAIL,GAAG,GAAG;AACR;AACJ;AACA;AACA;AACA;AACA;AACA;AACIM,IAAAA,QAAQ,EAAE,UAASC,IAAT,EAAeC,OAAf,EAAwB;AAChC;AACA,UAAIC,CAAC,GAAG,IAAIX,KAAK,CAACY,IAAN,CAAWC,UAAf,EAAR;AAEA;;AACA,UAAIC,GAAG,GAAGC,IAAI,CAACC,IAAL,CAAUN,OAAO,GAAGH,EAAE,CAACU,YAAvB,CAAV;;AACA,WAAI,IAAIC,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGJ,GAAnB,EAAwBI,CAAC,EAAzB,EAA6B;AAC3B;AACA,YAAIC,CAAC,GAAG,IAAInB,KAAK,CAACY,IAAN,CAAWC,UAAf,EAAR;AACAM,QAAAA,CAAC,CAACC,QAAF,CAAWF,CAAX;AAEA;AACR;;AACQX,QAAAA,EAAE,CAACc,KAAH;AACAd,QAAAA,EAAE,CAACe,MAAH,CAAUb,IAAI,GAAGU,CAAC,CAACI,QAAF,EAAjB;AACAZ,QAAAA,CAAC,CAACa,SAAF,CAAYjB,EAAE,CAACkB,MAAH,EAAZ;AACD;AAED;;;AACAd,MAAAA,CAAC,CAACe,QAAF,CAAWf,CAAC,CAACgB,MAAF,KAAajB,OAAxB;AACA,aAAOC,CAAC,CAACY,QAAF,EAAP;AACD;AA7BO,GAAV;AAgCA,SAAOrB,GAAP;AACD,CAlCD","sourcesContent":["/**\r\n * Javascript implementation of mask generation function MGF1.\r\n *\r\n * @author Stefan Siegl\r\n * @author Dave Longley\r\n *\r\n * Copyright (c) 2012 Stefan Siegl <stesie@brokenpipe.de>\r\n * Copyright (c) 2014 Digital Bazaar, Inc.\r\n */\r\nvar forge = require('./forge');\r\nrequire('./util');\r\n\r\nforge.mgf = forge.mgf || {};\r\nvar mgf1 = module.exports = forge.mgf.mgf1 = forge.mgf1 = forge.mgf1 || {};\r\n\r\n/**\r\n * Creates a MGF1 mask generation function object.\r\n *\r\n * @param md the message digest API to use (eg: forge.md.sha1.create()).\r\n *\r\n * @return a mask generation function object.\r\n */\r\nmgf1.create = function(md) {\r\n  var mgf = {\r\n    /**\r\n     * Generate mask of specified length.\r\n     *\r\n     * @param {String} seed The seed for mask generation.\r\n     * @param maskLen Number of bytes to generate.\r\n     * @return {String} The generated mask.\r\n     */\r\n    generate: function(seed, maskLen) {\r\n      /* 2. Let T be the empty octet string. */\r\n      var t = new forge.util.ByteBuffer();\r\n\r\n      /* 3. For counter from 0 to ceil(maskLen / hLen), do the following: */\r\n      var len = Math.ceil(maskLen / md.digestLength);\r\n      for(var i = 0; i < len; i++) {\r\n        /* a. Convert counter to an octet string C of length 4 octets */\r\n        var c = new forge.util.ByteBuffer();\r\n        c.putInt32(i);\r\n\r\n        /* b. Concatenate the hash of the seed mgfSeed and C to the octet\r\n         * string T: */\r\n        md.start();\r\n        md.update(seed + c.getBytes());\r\n        t.putBuffer(md.digest());\r\n      }\r\n\r\n      /* Output the leading maskLen octets of T as the octet string mask. */\r\n      t.truncate(t.length() - maskLen);\r\n      return t.getBytes();\r\n    }\r\n  };\r\n\r\n  return mgf;\r\n};\r\n"]},"metadata":{},"sourceType":"script"}