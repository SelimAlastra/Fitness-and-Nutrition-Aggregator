{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default('https-proxy-agent:parse-proxy-response');\n\nfunction parseProxyResponse(socket) {\n  return new Promise((resolve, reject) => {\n    // we need to buffer any HTTP traffic that happens with the proxy before we get\n    // the CONNECT response, so that if the response is anything other than an \"200\"\n    // response code, then we can re-play the \"data\" events on the socket once the\n    // HTTP parser is hooked up...\n    let buffersLength = 0;\n    const buffers = [];\n\n    function read() {\n      const b = socket.read();\n      if (b) ondata(b);else socket.once('readable', read);\n    }\n\n    function cleanup() {\n      socket.removeListener('end', onend);\n      socket.removeListener('error', onerror);\n      socket.removeListener('close', onclose);\n      socket.removeListener('readable', read);\n    }\n\n    function onclose(err) {\n      debug('onclose had error %o', err);\n    }\n\n    function onend() {\n      debug('onend');\n    }\n\n    function onerror(err) {\n      cleanup();\n      debug('onerror %o', err);\n      reject(err);\n    }\n\n    function ondata(b) {\n      buffers.push(b);\n      buffersLength += b.length;\n      const buffered = Buffer.concat(buffers, buffersLength);\n      const endOfHeaders = buffered.indexOf('\\r\\n\\r\\n');\n\n      if (endOfHeaders === -1) {\n        // keep buffering\n        debug('have not received end of HTTP headers yet...');\n        read();\n        return;\n      }\n\n      const firstLine = buffered.toString('ascii', 0, buffered.indexOf('\\r\\n'));\n      const statusCode = +firstLine.split(' ')[1];\n      debug('got proxy server response: %o', firstLine);\n      resolve({\n        statusCode,\n        buffered\n      });\n    }\n\n    socket.on('error', onerror);\n    socket.on('close', onclose);\n    socket.on('end', onend);\n    read();\n  });\n}\n\nexports.default = parseProxyResponse;","map":{"version":3,"sources":["../src/parse-proxy-response.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,MAAA,OAAA,GAAA,eAAA,CAAA,OAAA,CAAA,OAAA,CAAA,CAAA;;AAGA,MAAM,KAAK,GAAG,OAAA,CAAA,OAAA,CAAY,wCAAZ,CAAd;;AAOA,SAAwB,kBAAxB,CACC,MADD,EACiB;AAEhB,SAAO,IAAI,OAAJ,CAAY,CAAC,OAAD,EAAU,MAAV,KAAoB;AACtC;AACA;AACA;AACA;AACA,QAAI,aAAa,GAAG,CAApB;AACA,UAAM,OAAO,GAAa,EAA1B;;AAEA,aAAS,IAAT,GAAa;AACZ,YAAM,CAAC,GAAG,MAAM,CAAC,IAAP,EAAV;AACA,UAAI,CAAJ,EAAO,MAAM,CAAC,CAAD,CAAN,CAAP,KACK,MAAM,CAAC,IAAP,CAAY,UAAZ,EAAwB,IAAxB;AACL;;AAED,aAAS,OAAT,GAAgB;AACf,MAAA,MAAM,CAAC,cAAP,CAAsB,KAAtB,EAA6B,KAA7B;AACA,MAAA,MAAM,CAAC,cAAP,CAAsB,OAAtB,EAA+B,OAA/B;AACA,MAAA,MAAM,CAAC,cAAP,CAAsB,OAAtB,EAA+B,OAA/B;AACA,MAAA,MAAM,CAAC,cAAP,CAAsB,UAAtB,EAAkC,IAAlC;AACA;;AAED,aAAS,OAAT,CAAiB,GAAjB,EAA4B;AAC3B,MAAA,KAAK,CAAC,sBAAD,EAAyB,GAAzB,CAAL;AACA;;AAED,aAAS,KAAT,GAAc;AACb,MAAA,KAAK,CAAC,OAAD,CAAL;AACA;;AAED,aAAS,OAAT,CAAiB,GAAjB,EAA2B;AAC1B,MAAA,OAAO;AACP,MAAA,KAAK,CAAC,YAAD,EAAe,GAAf,CAAL;AACA,MAAA,MAAM,CAAC,GAAD,CAAN;AACA;;AAED,aAAS,MAAT,CAAgB,CAAhB,EAAyB;AACxB,MAAA,OAAO,CAAC,IAAR,CAAa,CAAb;AACA,MAAA,aAAa,IAAI,CAAC,CAAC,MAAnB;AAEA,YAAM,QAAQ,GAAG,MAAM,CAAC,MAAP,CAAc,OAAd,EAAuB,aAAvB,CAAjB;AACA,YAAM,YAAY,GAAG,QAAQ,CAAC,OAAT,CAAiB,UAAjB,CAArB;;AAEA,UAAI,YAAY,KAAK,CAAC,CAAtB,EAAyB;AACxB;AACA,QAAA,KAAK,CAAC,8CAAD,CAAL;AACA,QAAA,IAAI;AACJ;AACA;;AAED,YAAM,SAAS,GAAG,QAAQ,CAAC,QAAT,CACjB,OADiB,EAEjB,CAFiB,EAGjB,QAAQ,CAAC,OAAT,CAAiB,MAAjB,CAHiB,CAAlB;AAKA,YAAM,UAAU,GAAG,CAAC,SAAS,CAAC,KAAV,CAAgB,GAAhB,EAAqB,CAArB,CAApB;AACA,MAAA,KAAK,CAAC,+BAAD,EAAkC,SAAlC,CAAL;AACA,MAAA,OAAO,CAAC;AACP,QAAA,UADO;AAEP,QAAA;AAFO,OAAD,CAAP;AAIA;;AAED,IAAA,MAAM,CAAC,EAAP,CAAU,OAAV,EAAmB,OAAnB;AACA,IAAA,MAAM,CAAC,EAAP,CAAU,OAAV,EAAmB,OAAnB;AACA,IAAA,MAAM,CAAC,EAAP,CAAU,KAAV,EAAiB,KAAjB;AAEA,IAAA,IAAI;AACJ,GAnEM,CAAP;AAoEA;;AAvED,OAAA,CAAA,OAAA,GAAA,kBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst debug_1 = __importDefault(require(\"debug\"));\r\nconst debug = debug_1.default('https-proxy-agent:parse-proxy-response');\r\nfunction parseProxyResponse(socket) {\r\n    return new Promise((resolve, reject) => {\r\n        // we need to buffer any HTTP traffic that happens with the proxy before we get\r\n        // the CONNECT response, so that if the response is anything other than an \"200\"\r\n        // response code, then we can re-play the \"data\" events on the socket once the\r\n        // HTTP parser is hooked up...\r\n        let buffersLength = 0;\r\n        const buffers = [];\r\n        function read() {\r\n            const b = socket.read();\r\n            if (b)\r\n                ondata(b);\r\n            else\r\n                socket.once('readable', read);\r\n        }\r\n        function cleanup() {\r\n            socket.removeListener('end', onend);\r\n            socket.removeListener('error', onerror);\r\n            socket.removeListener('close', onclose);\r\n            socket.removeListener('readable', read);\r\n        }\r\n        function onclose(err) {\r\n            debug('onclose had error %o', err);\r\n        }\r\n        function onend() {\r\n            debug('onend');\r\n        }\r\n        function onerror(err) {\r\n            cleanup();\r\n            debug('onerror %o', err);\r\n            reject(err);\r\n        }\r\n        function ondata(b) {\r\n            buffers.push(b);\r\n            buffersLength += b.length;\r\n            const buffered = Buffer.concat(buffers, buffersLength);\r\n            const endOfHeaders = buffered.indexOf('\\r\\n\\r\\n');\r\n            if (endOfHeaders === -1) {\r\n                // keep buffering\r\n                debug('have not received end of HTTP headers yet...');\r\n                read();\r\n                return;\r\n            }\r\n            const firstLine = buffered.toString('ascii', 0, buffered.indexOf('\\r\\n'));\r\n            const statusCode = +firstLine.split(' ')[1];\r\n            debug('got proxy server response: %o', firstLine);\r\n            resolve({\r\n                statusCode,\r\n                buffered\r\n            });\r\n        }\r\n        socket.on('error', onerror);\r\n        socket.on('close', onclose);\r\n        socket.on('end', onend);\r\n        read();\r\n    });\r\n}\r\nexports.default = parseProxyResponse;\r\n//# sourceMappingURL=parse-proxy-response.js.map"]},"metadata":{},"sourceType":"script"}