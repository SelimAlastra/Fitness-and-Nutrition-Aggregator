{"ast":null,"code":"/**\r\n * Cipher base API.\r\n *\r\n * @author Dave Longley\r\n *\r\n * Copyright (c) 2010-2014 Digital Bazaar, Inc.\r\n */\nvar forge = require('./forge');\n\nrequire('./util');\n\nmodule.exports = forge.cipher = forge.cipher || {}; // registered algorithms\n\nforge.cipher.algorithms = forge.cipher.algorithms || {};\n/**\r\n * Creates a cipher object that can be used to encrypt data using the given\r\n * algorithm and key. The algorithm may be provided as a string value for a\r\n * previously registered algorithm or it may be given as a cipher algorithm\r\n * API object.\r\n *\r\n * @param algorithm the algorithm to use, either a string or an algorithm API\r\n *          object.\r\n * @param key the key to use, as a binary-encoded string of bytes or a\r\n *          byte buffer.\r\n *\r\n * @return the cipher.\r\n */\n\nforge.cipher.createCipher = function (algorithm, key) {\n  var api = algorithm;\n\n  if (typeof api === 'string') {\n    api = forge.cipher.getAlgorithm(api);\n\n    if (api) {\n      api = api();\n    }\n  }\n\n  if (!api) {\n    throw new Error('Unsupported algorithm: ' + algorithm);\n  } // assume block cipher\n\n\n  return new forge.cipher.BlockCipher({\n    algorithm: api,\n    key: key,\n    decrypt: false\n  });\n};\n/**\r\n * Creates a decipher object that can be used to decrypt data using the given\r\n * algorithm and key. The algorithm may be provided as a string value for a\r\n * previously registered algorithm or it may be given as a cipher algorithm\r\n * API object.\r\n *\r\n * @param algorithm the algorithm to use, either a string or an algorithm API\r\n *          object.\r\n * @param key the key to use, as a binary-encoded string of bytes or a\r\n *          byte buffer.\r\n *\r\n * @return the cipher.\r\n */\n\n\nforge.cipher.createDecipher = function (algorithm, key) {\n  var api = algorithm;\n\n  if (typeof api === 'string') {\n    api = forge.cipher.getAlgorithm(api);\n\n    if (api) {\n      api = api();\n    }\n  }\n\n  if (!api) {\n    throw new Error('Unsupported algorithm: ' + algorithm);\n  } // assume block cipher\n\n\n  return new forge.cipher.BlockCipher({\n    algorithm: api,\n    key: key,\n    decrypt: true\n  });\n};\n/**\r\n * Registers an algorithm by name. If the name was already registered, the\r\n * algorithm API object will be overwritten.\r\n *\r\n * @param name the name of the algorithm.\r\n * @param algorithm the algorithm API object.\r\n */\n\n\nforge.cipher.registerAlgorithm = function (name, algorithm) {\n  name = name.toUpperCase();\n  forge.cipher.algorithms[name] = algorithm;\n};\n/**\r\n * Gets a registered algorithm by name.\r\n *\r\n * @param name the name of the algorithm.\r\n *\r\n * @return the algorithm, if found, null if not.\r\n */\n\n\nforge.cipher.getAlgorithm = function (name) {\n  name = name.toUpperCase();\n\n  if (name in forge.cipher.algorithms) {\n    return forge.cipher.algorithms[name];\n  }\n\n  return null;\n};\n\nvar BlockCipher = forge.cipher.BlockCipher = function (options) {\n  this.algorithm = options.algorithm;\n  this.mode = this.algorithm.mode;\n  this.blockSize = this.mode.blockSize;\n  this._finish = false;\n  this._input = null;\n  this.output = null;\n  this._op = options.decrypt ? this.mode.decrypt : this.mode.encrypt;\n  this._decrypt = options.decrypt;\n  this.algorithm.initialize(options);\n};\n/**\r\n * Starts or restarts the encryption or decryption process, whichever\r\n * was previously configured.\r\n *\r\n * For non-GCM mode, the IV may be a binary-encoded string of bytes, an array\r\n * of bytes, a byte buffer, or an array of 32-bit integers. If the IV is in\r\n * bytes, then it must be Nb (16) bytes in length. If the IV is given in as\r\n * 32-bit integers, then it must be 4 integers long.\r\n *\r\n * Note: an IV is not required or used in ECB mode.\r\n *\r\n * For GCM-mode, the IV must be given as a binary-encoded string of bytes or\r\n * a byte buffer. The number of bytes should be 12 (96 bits) as recommended\r\n * by NIST SP-800-38D but another length may be given.\r\n *\r\n * @param options the options to use:\r\n *          iv the initialization vector to use as a binary-encoded string of\r\n *            bytes, null to reuse the last ciphered block from a previous\r\n *            update() (this \"residue\" method is for legacy support only).\r\n *          additionalData additional authentication data as a binary-encoded\r\n *            string of bytes, for 'GCM' mode, (default: none).\r\n *          tagLength desired length of authentication tag, in bits, for\r\n *            'GCM' mode (0-128, default: 128).\r\n *          tag the authentication tag to check if decrypting, as a\r\n *             binary-encoded string of bytes.\r\n *          output the output the buffer to write to, null to create one.\r\n */\n\n\nBlockCipher.prototype.start = function (options) {\n  options = options || {};\n  var opts = {};\n\n  for (var key in options) {\n    opts[key] = options[key];\n  }\n\n  opts.decrypt = this._decrypt;\n  this._finish = false;\n  this._input = forge.util.createBuffer();\n  this.output = options.output || forge.util.createBuffer();\n  this.mode.start(opts);\n};\n/**\r\n * Updates the next block according to the cipher mode.\r\n *\r\n * @param input the buffer to read from.\r\n */\n\n\nBlockCipher.prototype.update = function (input) {\n  if (input) {\n    // input given, so empty it into the input buffer\n    this._input.putBuffer(input);\n  } // do cipher operation until it needs more input and not finished\n\n\n  while (!this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish) {} // free consumed memory from input buffer\n\n\n  this._input.compact();\n};\n/**\r\n * Finishes encrypting or decrypting.\r\n *\r\n * @param pad a padding function to use in CBC mode, null for default,\r\n *          signature(blockSize, buffer, decrypt).\r\n *\r\n * @return true if successful, false on error.\r\n */\n\n\nBlockCipher.prototype.finish = function (pad) {\n  // backwards-compatibility w/deprecated padding API\n  // Note: will overwrite padding functions even after another start() call\n  if (pad && (this.mode.name === 'ECB' || this.mode.name === 'CBC')) {\n    this.mode.pad = function (input) {\n      return pad(this.blockSize, input, false);\n    };\n\n    this.mode.unpad = function (output) {\n      return pad(this.blockSize, output, true);\n    };\n  } // build options for padding and afterFinish functions\n\n\n  var options = {};\n  options.decrypt = this._decrypt; // get # of bytes that won't fill a block\n\n  options.overflow = this._input.length() % this.blockSize;\n\n  if (!this._decrypt && this.mode.pad) {\n    if (!this.mode.pad(this._input, options)) {\n      return false;\n    }\n  } // do final update\n\n\n  this._finish = true;\n  this.update();\n\n  if (this._decrypt && this.mode.unpad) {\n    if (!this.mode.unpad(this.output, options)) {\n      return false;\n    }\n  }\n\n  if (this.mode.afterFinish) {\n    if (!this.mode.afterFinish(this.output, options)) {\n      return false;\n    }\n  }\n\n  return true;\n};","map":{"version":3,"sources":["C:/Users/ibott/MajorGroupProject/node_modules/node-forge/lib/cipher.js"],"names":["forge","require","module","exports","cipher","algorithms","createCipher","algorithm","key","api","getAlgorithm","Error","BlockCipher","decrypt","createDecipher","registerAlgorithm","name","toUpperCase","options","mode","blockSize","_finish","_input","output","_op","encrypt","_decrypt","initialize","prototype","start","opts","util","createBuffer","update","input","putBuffer","call","compact","finish","pad","unpad","overflow","length","afterFinish"],"mappings":"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","sourcesContent":["/**\r\n * Cipher base API.\r\n *\r\n * @author Dave Longley\r\n *\r\n * Copyright (c) 2010-2014 Digital Bazaar, Inc.\r\n */\r\nvar forge = require('./forge');\r\nrequire('./util');\r\n\r\nmodule.exports = forge.cipher = forge.cipher || {};\r\n\r\n// registered algorithms\r\nforge.cipher.algorithms = forge.cipher.algorithms || {};\r\n\r\n/**\r\n * Creates a cipher object that can be used to encrypt data using the given\r\n * algorithm and key. The algorithm may be provided as a string value for a\r\n * previously registered algorithm or it may be given as a cipher algorithm\r\n * API object.\r\n *\r\n * @param algorithm the algorithm to use, either a string or an algorithm API\r\n *          object.\r\n * @param key the key to use, as a binary-encoded string of bytes or a\r\n *          byte buffer.\r\n *\r\n * @return the cipher.\r\n */\r\nforge.cipher.createCipher = function(algorithm, key) {\r\n  var api = algorithm;\r\n  if(typeof api === 'string') {\r\n    api = forge.cipher.getAlgorithm(api);\r\n    if(api) {\r\n      api = api();\r\n    }\r\n  }\r\n  if(!api) {\r\n    throw new Error('Unsupported algorithm: ' + algorithm);\r\n  }\r\n\r\n  // assume block cipher\r\n  return new forge.cipher.BlockCipher({\r\n    algorithm: api,\r\n    key: key,\r\n    decrypt: false\r\n  });\r\n};\r\n\r\n/**\r\n * Creates a decipher object that can be used to decrypt data using the given\r\n * algorithm and key. The algorithm may be provided as a string value for a\r\n * previously registered algorithm or it may be given as a cipher algorithm\r\n * API object.\r\n *\r\n * @param algorithm the algorithm to use, either a string or an algorithm API\r\n *          object.\r\n * @param key the key to use, as a binary-encoded string of bytes or a\r\n *          byte buffer.\r\n *\r\n * @return the cipher.\r\n */\r\nforge.cipher.createDecipher = function(algorithm, key) {\r\n  var api = algorithm;\r\n  if(typeof api === 'string') {\r\n    api = forge.cipher.getAlgorithm(api);\r\n    if(api) {\r\n      api = api();\r\n    }\r\n  }\r\n  if(!api) {\r\n    throw new Error('Unsupported algorithm: ' + algorithm);\r\n  }\r\n\r\n  // assume block cipher\r\n  return new forge.cipher.BlockCipher({\r\n    algorithm: api,\r\n    key: key,\r\n    decrypt: true\r\n  });\r\n};\r\n\r\n/**\r\n * Registers an algorithm by name. If the name was already registered, the\r\n * algorithm API object will be overwritten.\r\n *\r\n * @param name the name of the algorithm.\r\n * @param algorithm the algorithm API object.\r\n */\r\nforge.cipher.registerAlgorithm = function(name, algorithm) {\r\n  name = name.toUpperCase();\r\n  forge.cipher.algorithms[name] = algorithm;\r\n};\r\n\r\n/**\r\n * Gets a registered algorithm by name.\r\n *\r\n * @param name the name of the algorithm.\r\n *\r\n * @return the algorithm, if found, null if not.\r\n */\r\nforge.cipher.getAlgorithm = function(name) {\r\n  name = name.toUpperCase();\r\n  if(name in forge.cipher.algorithms) {\r\n    return forge.cipher.algorithms[name];\r\n  }\r\n  return null;\r\n};\r\n\r\nvar BlockCipher = forge.cipher.BlockCipher = function(options) {\r\n  this.algorithm = options.algorithm;\r\n  this.mode = this.algorithm.mode;\r\n  this.blockSize = this.mode.blockSize;\r\n  this._finish = false;\r\n  this._input = null;\r\n  this.output = null;\r\n  this._op = options.decrypt ? this.mode.decrypt : this.mode.encrypt;\r\n  this._decrypt = options.decrypt;\r\n  this.algorithm.initialize(options);\r\n};\r\n\r\n/**\r\n * Starts or restarts the encryption or decryption process, whichever\r\n * was previously configured.\r\n *\r\n * For non-GCM mode, the IV may be a binary-encoded string of bytes, an array\r\n * of bytes, a byte buffer, or an array of 32-bit integers. If the IV is in\r\n * bytes, then it must be Nb (16) bytes in length. If the IV is given in as\r\n * 32-bit integers, then it must be 4 integers long.\r\n *\r\n * Note: an IV is not required or used in ECB mode.\r\n *\r\n * For GCM-mode, the IV must be given as a binary-encoded string of bytes or\r\n * a byte buffer. The number of bytes should be 12 (96 bits) as recommended\r\n * by NIST SP-800-38D but another length may be given.\r\n *\r\n * @param options the options to use:\r\n *          iv the initialization vector to use as a binary-encoded string of\r\n *            bytes, null to reuse the last ciphered block from a previous\r\n *            update() (this \"residue\" method is for legacy support only).\r\n *          additionalData additional authentication data as a binary-encoded\r\n *            string of bytes, for 'GCM' mode, (default: none).\r\n *          tagLength desired length of authentication tag, in bits, for\r\n *            'GCM' mode (0-128, default: 128).\r\n *          tag the authentication tag to check if decrypting, as a\r\n *             binary-encoded string of bytes.\r\n *          output the output the buffer to write to, null to create one.\r\n */\r\nBlockCipher.prototype.start = function(options) {\r\n  options = options || {};\r\n  var opts = {};\r\n  for(var key in options) {\r\n    opts[key] = options[key];\r\n  }\r\n  opts.decrypt = this._decrypt;\r\n  this._finish = false;\r\n  this._input = forge.util.createBuffer();\r\n  this.output = options.output || forge.util.createBuffer();\r\n  this.mode.start(opts);\r\n};\r\n\r\n/**\r\n * Updates the next block according to the cipher mode.\r\n *\r\n * @param input the buffer to read from.\r\n */\r\nBlockCipher.prototype.update = function(input) {\r\n  if(input) {\r\n    // input given, so empty it into the input buffer\r\n    this._input.putBuffer(input);\r\n  }\r\n\r\n  // do cipher operation until it needs more input and not finished\r\n  while(!this._op.call(this.mode, this._input, this.output, this._finish) &&\r\n    !this._finish) {}\r\n\r\n  // free consumed memory from input buffer\r\n  this._input.compact();\r\n};\r\n\r\n/**\r\n * Finishes encrypting or decrypting.\r\n *\r\n * @param pad a padding function to use in CBC mode, null for default,\r\n *          signature(blockSize, buffer, decrypt).\r\n *\r\n * @return true if successful, false on error.\r\n */\r\nBlockCipher.prototype.finish = function(pad) {\r\n  // backwards-compatibility w/deprecated padding API\r\n  // Note: will overwrite padding functions even after another start() call\r\n  if(pad && (this.mode.name === 'ECB' || this.mode.name === 'CBC')) {\r\n    this.mode.pad = function(input) {\r\n      return pad(this.blockSize, input, false);\r\n    };\r\n    this.mode.unpad = function(output) {\r\n      return pad(this.blockSize, output, true);\r\n    };\r\n  }\r\n\r\n  // build options for padding and afterFinish functions\r\n  var options = {};\r\n  options.decrypt = this._decrypt;\r\n\r\n  // get # of bytes that won't fill a block\r\n  options.overflow = this._input.length() % this.blockSize;\r\n\r\n  if(!this._decrypt && this.mode.pad) {\r\n    if(!this.mode.pad(this._input, options)) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // do final update\r\n  this._finish = true;\r\n  this.update();\r\n\r\n  if(this._decrypt && this.mode.unpad) {\r\n    if(!this.mode.unpad(this.output, options)) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  if(this.mode.afterFinish) {\r\n    if(!this.mode.afterFinish(this.output, options)) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n};\r\n"]},"metadata":{},"sourceType":"script"}