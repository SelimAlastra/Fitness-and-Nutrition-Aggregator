{"ast":null,"code":"/**\r\n * Functions to output keys in SSH-friendly formats.\r\n *\r\n * This is part of the Forge project which may be used under the terms of\r\n * either the BSD License or the GNU General Public License (GPL) Version 2.\r\n *\r\n * See: https://github.com/digitalbazaar/forge/blob/cbebca3780658703d925b61b2caffb1d263a6c1d/LICENSE\r\n *\r\n * @author https://github.com/shellac\r\n */\nvar forge = require('./forge');\n\nrequire('./aes');\n\nrequire('./hmac');\n\nrequire('./md5');\n\nrequire('./sha1');\n\nrequire('./util');\n\nvar ssh = module.exports = forge.ssh = forge.ssh || {};\n/**\r\n * Encodes (and optionally encrypts) a private RSA key as a Putty PPK file.\r\n *\r\n * @param privateKey the key.\r\n * @param passphrase a passphrase to protect the key (falsy for no encryption).\r\n * @param comment a comment to include in the key file.\r\n *\r\n * @return the PPK file as a string.\r\n */\n\nssh.privateKeyToPutty = function (privateKey, passphrase, comment) {\n  comment = comment || '';\n  passphrase = passphrase || '';\n  var algorithm = 'ssh-rsa';\n  var encryptionAlgorithm = passphrase === '' ? 'none' : 'aes256-cbc';\n  var ppk = 'PuTTY-User-Key-File-2: ' + algorithm + '\\r\\n';\n  ppk += 'Encryption: ' + encryptionAlgorithm + '\\r\\n';\n  ppk += 'Comment: ' + comment + '\\r\\n'; // public key into buffer for ppk\n\n  var pubbuffer = forge.util.createBuffer();\n\n  _addStringToBuffer(pubbuffer, algorithm);\n\n  _addBigIntegerToBuffer(pubbuffer, privateKey.e);\n\n  _addBigIntegerToBuffer(pubbuffer, privateKey.n); // write public key\n\n\n  var pub = forge.util.encode64(pubbuffer.bytes(), 64);\n  var length = Math.floor(pub.length / 66) + 1; // 66 = 64 + \\r\\n\n\n  ppk += 'Public-Lines: ' + length + '\\r\\n';\n  ppk += pub; // private key into a buffer\n\n  var privbuffer = forge.util.createBuffer();\n\n  _addBigIntegerToBuffer(privbuffer, privateKey.d);\n\n  _addBigIntegerToBuffer(privbuffer, privateKey.p);\n\n  _addBigIntegerToBuffer(privbuffer, privateKey.q);\n\n  _addBigIntegerToBuffer(privbuffer, privateKey.qInv); // optionally encrypt the private key\n\n\n  var priv;\n\n  if (!passphrase) {\n    // use the unencrypted buffer\n    priv = forge.util.encode64(privbuffer.bytes(), 64);\n  } else {\n    // encrypt RSA key using passphrase\n    var encLen = privbuffer.length() + 16 - 1;\n    encLen -= encLen % 16; // pad private key with sha1-d data -- needs to be a multiple of 16\n\n    var padding = _sha1(privbuffer.bytes());\n\n    padding.truncate(padding.length() - encLen + privbuffer.length());\n    privbuffer.putBuffer(padding);\n    var aeskey = forge.util.createBuffer();\n    aeskey.putBuffer(_sha1('\\x00\\x00\\x00\\x00', passphrase));\n    aeskey.putBuffer(_sha1('\\x00\\x00\\x00\\x01', passphrase)); // encrypt some bytes using CBC mode\n    // key is 40 bytes, so truncate *by* 8 bytes\n\n    var cipher = forge.aes.createEncryptionCipher(aeskey.truncate(8), 'CBC');\n    cipher.start(forge.util.createBuffer().fillWithByte(0, 16));\n    cipher.update(privbuffer.copy());\n    cipher.finish();\n    var encrypted = cipher.output; // Note: this appears to differ from Putty -- is forge wrong, or putty?\n    // due to padding we finish as an exact multiple of 16\n\n    encrypted.truncate(16); // all padding\n\n    priv = forge.util.encode64(encrypted.bytes(), 64);\n  } // output private key\n\n\n  length = Math.floor(priv.length / 66) + 1; // 64 + \\r\\n\n\n  ppk += '\\r\\nPrivate-Lines: ' + length + '\\r\\n';\n  ppk += priv; // MAC\n\n  var mackey = _sha1('putty-private-key-file-mac-key', passphrase);\n\n  var macbuffer = forge.util.createBuffer();\n\n  _addStringToBuffer(macbuffer, algorithm);\n\n  _addStringToBuffer(macbuffer, encryptionAlgorithm);\n\n  _addStringToBuffer(macbuffer, comment);\n\n  macbuffer.putInt32(pubbuffer.length());\n  macbuffer.putBuffer(pubbuffer);\n  macbuffer.putInt32(privbuffer.length());\n  macbuffer.putBuffer(privbuffer);\n  var hmac = forge.hmac.create();\n  hmac.start('sha1', mackey);\n  hmac.update(macbuffer.bytes());\n  ppk += '\\r\\nPrivate-MAC: ' + hmac.digest().toHex() + '\\r\\n';\n  return ppk;\n};\n/**\r\n * Encodes a public RSA key as an OpenSSH file.\r\n *\r\n * @param key the key.\r\n * @param comment a comment.\r\n *\r\n * @return the public key in OpenSSH format.\r\n */\n\n\nssh.publicKeyToOpenSSH = function (key, comment) {\n  var type = 'ssh-rsa';\n  comment = comment || '';\n  var buffer = forge.util.createBuffer();\n\n  _addStringToBuffer(buffer, type);\n\n  _addBigIntegerToBuffer(buffer, key.e);\n\n  _addBigIntegerToBuffer(buffer, key.n);\n\n  return type + ' ' + forge.util.encode64(buffer.bytes()) + ' ' + comment;\n};\n/**\r\n * Encodes a private RSA key as an OpenSSH file.\r\n *\r\n * @param key the key.\r\n * @param passphrase a passphrase to protect the key (falsy for no encryption).\r\n *\r\n * @return the public key in OpenSSH format.\r\n */\n\n\nssh.privateKeyToOpenSSH = function (privateKey, passphrase) {\n  if (!passphrase) {\n    return forge.pki.privateKeyToPem(privateKey);\n  } // OpenSSH private key is just a legacy format, it seems\n\n\n  return forge.pki.encryptRsaPrivateKey(privateKey, passphrase, {\n    legacy: true,\n    algorithm: 'aes128'\n  });\n};\n/**\r\n * Gets the SSH fingerprint for the given public key.\r\n *\r\n * @param options the options to use.\r\n *          [md] the message digest object to use (defaults to forge.md.md5).\r\n *          [encoding] an alternative output encoding, such as 'hex'\r\n *            (defaults to none, outputs a byte buffer).\r\n *          [delimiter] the delimiter to use between bytes for 'hex' encoded\r\n *            output, eg: ':' (defaults to none).\r\n *\r\n * @return the fingerprint as a byte buffer or other encoding based on options.\r\n */\n\n\nssh.getPublicKeyFingerprint = function (key, options) {\n  options = options || {};\n  var md = options.md || forge.md.md5.create();\n  var type = 'ssh-rsa';\n  var buffer = forge.util.createBuffer();\n\n  _addStringToBuffer(buffer, type);\n\n  _addBigIntegerToBuffer(buffer, key.e);\n\n  _addBigIntegerToBuffer(buffer, key.n); // hash public key bytes\n\n\n  md.start();\n  md.update(buffer.getBytes());\n  var digest = md.digest();\n\n  if (options.encoding === 'hex') {\n    var hex = digest.toHex();\n\n    if (options.delimiter) {\n      return hex.match(/.{2}/g).join(options.delimiter);\n    }\n\n    return hex;\n  } else if (options.encoding === 'binary') {\n    return digest.getBytes();\n  } else if (options.encoding) {\n    throw new Error('Unknown encoding \"' + options.encoding + '\".');\n  }\n\n  return digest;\n};\n/**\r\n * Adds len(val) then val to a buffer.\r\n *\r\n * @param buffer the buffer to add to.\r\n * @param val a big integer.\r\n */\n\n\nfunction _addBigIntegerToBuffer(buffer, val) {\n  var hexVal = val.toString(16); // ensure 2s complement +ve\n\n  if (hexVal[0] >= '8') {\n    hexVal = '00' + hexVal;\n  }\n\n  var bytes = forge.util.hexToBytes(hexVal);\n  buffer.putInt32(bytes.length);\n  buffer.putBytes(bytes);\n}\n/**\r\n * Adds len(val) then val to a buffer.\r\n *\r\n * @param buffer the buffer to add to.\r\n * @param val a string.\r\n */\n\n\nfunction _addStringToBuffer(buffer, val) {\n  buffer.putInt32(val.length);\n  buffer.putString(val);\n}\n/**\r\n * Hashes the arguments into one value using SHA-1.\r\n *\r\n * @return the sha1 hash of the provided arguments.\r\n */\n\n\nfunction _sha1() {\n  var sha = forge.md.sha1.create();\n  var num = arguments.length;\n\n  for (var i = 0; i < num; ++i) {\n    sha.update(arguments[i]);\n  }\n\n  return sha.digest();\n}","map":{"version":3,"sources":["C:/Users/ibott/MajorGroupProject/node_modules/node-forge/lib/ssh.js"],"names":["forge","require","ssh","module","exports","privateKeyToPutty","privateKey","passphrase","comment","algorithm","encryptionAlgorithm","ppk","pubbuffer","util","createBuffer","_addStringToBuffer","_addBigIntegerToBuffer","e","n","pub","encode64","bytes","length","Math","floor","privbuffer","d","p","q","qInv","priv","encLen","padding","_sha1","truncate","putBuffer","aeskey","cipher","aes","createEncryptionCipher","start","fillWithByte","update","copy","finish","encrypted","output","mackey","macbuffer","putInt32","hmac","create","digest","toHex","publicKeyToOpenSSH","key","type","buffer","privateKeyToOpenSSH","pki","privateKeyToPem","encryptRsaPrivateKey","legacy","getPublicKeyFingerprint","options","md","md5","getBytes","encoding","hex","delimiter","match","join","Error","val","hexVal","toString","hexToBytes","putBytes","putString","sha","sha1","num","arguments","i"],"mappings":"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","sourcesContent":["/**\r\n * Functions to output keys in SSH-friendly formats.\r\n *\r\n * This is part of the Forge project which may be used under the terms of\r\n * either the BSD License or the GNU General Public License (GPL) Version 2.\r\n *\r\n * See: https://github.com/digitalbazaar/forge/blob/cbebca3780658703d925b61b2caffb1d263a6c1d/LICENSE\r\n *\r\n * @author https://github.com/shellac\r\n */\r\nvar forge = require('./forge');\r\nrequire('./aes');\r\nrequire('./hmac');\r\nrequire('./md5');\r\nrequire('./sha1');\r\nrequire('./util');\r\n\r\nvar ssh = module.exports = forge.ssh = forge.ssh || {};\r\n\r\n/**\r\n * Encodes (and optionally encrypts) a private RSA key as a Putty PPK file.\r\n *\r\n * @param privateKey the key.\r\n * @param passphrase a passphrase to protect the key (falsy for no encryption).\r\n * @param comment a comment to include in the key file.\r\n *\r\n * @return the PPK file as a string.\r\n */\r\nssh.privateKeyToPutty = function(privateKey, passphrase, comment) {\r\n  comment = comment || '';\r\n  passphrase = passphrase || '';\r\n  var algorithm = 'ssh-rsa';\r\n  var encryptionAlgorithm = (passphrase === '') ? 'none' : 'aes256-cbc';\r\n\r\n  var ppk = 'PuTTY-User-Key-File-2: ' + algorithm + '\\r\\n';\r\n  ppk += 'Encryption: ' + encryptionAlgorithm + '\\r\\n';\r\n  ppk += 'Comment: ' + comment + '\\r\\n';\r\n\r\n  // public key into buffer for ppk\r\n  var pubbuffer = forge.util.createBuffer();\r\n  _addStringToBuffer(pubbuffer, algorithm);\r\n  _addBigIntegerToBuffer(pubbuffer, privateKey.e);\r\n  _addBigIntegerToBuffer(pubbuffer, privateKey.n);\r\n\r\n  // write public key\r\n  var pub = forge.util.encode64(pubbuffer.bytes(), 64);\r\n  var length = Math.floor(pub.length / 66) + 1; // 66 = 64 + \\r\\n\r\n  ppk += 'Public-Lines: ' + length + '\\r\\n';\r\n  ppk += pub;\r\n\r\n  // private key into a buffer\r\n  var privbuffer = forge.util.createBuffer();\r\n  _addBigIntegerToBuffer(privbuffer, privateKey.d);\r\n  _addBigIntegerToBuffer(privbuffer, privateKey.p);\r\n  _addBigIntegerToBuffer(privbuffer, privateKey.q);\r\n  _addBigIntegerToBuffer(privbuffer, privateKey.qInv);\r\n\r\n  // optionally encrypt the private key\r\n  var priv;\r\n  if(!passphrase) {\r\n    // use the unencrypted buffer\r\n    priv = forge.util.encode64(privbuffer.bytes(), 64);\r\n  } else {\r\n    // encrypt RSA key using passphrase\r\n    var encLen = privbuffer.length() + 16 - 1;\r\n    encLen -= encLen % 16;\r\n\r\n    // pad private key with sha1-d data -- needs to be a multiple of 16\r\n    var padding = _sha1(privbuffer.bytes());\r\n\r\n    padding.truncate(padding.length() - encLen + privbuffer.length());\r\n    privbuffer.putBuffer(padding);\r\n\r\n    var aeskey = forge.util.createBuffer();\r\n    aeskey.putBuffer(_sha1('\\x00\\x00\\x00\\x00', passphrase));\r\n    aeskey.putBuffer(_sha1('\\x00\\x00\\x00\\x01', passphrase));\r\n\r\n    // encrypt some bytes using CBC mode\r\n    // key is 40 bytes, so truncate *by* 8 bytes\r\n    var cipher = forge.aes.createEncryptionCipher(aeskey.truncate(8), 'CBC');\r\n    cipher.start(forge.util.createBuffer().fillWithByte(0, 16));\r\n    cipher.update(privbuffer.copy());\r\n    cipher.finish();\r\n    var encrypted = cipher.output;\r\n\r\n    // Note: this appears to differ from Putty -- is forge wrong, or putty?\r\n    // due to padding we finish as an exact multiple of 16\r\n    encrypted.truncate(16); // all padding\r\n\r\n    priv = forge.util.encode64(encrypted.bytes(), 64);\r\n  }\r\n\r\n  // output private key\r\n  length = Math.floor(priv.length / 66) + 1; // 64 + \\r\\n\r\n  ppk += '\\r\\nPrivate-Lines: ' + length + '\\r\\n';\r\n  ppk += priv;\r\n\r\n  // MAC\r\n  var mackey = _sha1('putty-private-key-file-mac-key', passphrase);\r\n\r\n  var macbuffer = forge.util.createBuffer();\r\n  _addStringToBuffer(macbuffer, algorithm);\r\n  _addStringToBuffer(macbuffer, encryptionAlgorithm);\r\n  _addStringToBuffer(macbuffer, comment);\r\n  macbuffer.putInt32(pubbuffer.length());\r\n  macbuffer.putBuffer(pubbuffer);\r\n  macbuffer.putInt32(privbuffer.length());\r\n  macbuffer.putBuffer(privbuffer);\r\n\r\n  var hmac = forge.hmac.create();\r\n  hmac.start('sha1', mackey);\r\n  hmac.update(macbuffer.bytes());\r\n\r\n  ppk += '\\r\\nPrivate-MAC: ' + hmac.digest().toHex() + '\\r\\n';\r\n\r\n  return ppk;\r\n};\r\n\r\n/**\r\n * Encodes a public RSA key as an OpenSSH file.\r\n *\r\n * @param key the key.\r\n * @param comment a comment.\r\n *\r\n * @return the public key in OpenSSH format.\r\n */\r\nssh.publicKeyToOpenSSH = function(key, comment) {\r\n  var type = 'ssh-rsa';\r\n  comment = comment || '';\r\n\r\n  var buffer = forge.util.createBuffer();\r\n  _addStringToBuffer(buffer, type);\r\n  _addBigIntegerToBuffer(buffer, key.e);\r\n  _addBigIntegerToBuffer(buffer, key.n);\r\n\r\n  return type + ' ' + forge.util.encode64(buffer.bytes()) + ' ' + comment;\r\n};\r\n\r\n/**\r\n * Encodes a private RSA key as an OpenSSH file.\r\n *\r\n * @param key the key.\r\n * @param passphrase a passphrase to protect the key (falsy for no encryption).\r\n *\r\n * @return the public key in OpenSSH format.\r\n */\r\nssh.privateKeyToOpenSSH = function(privateKey, passphrase) {\r\n  if(!passphrase) {\r\n    return forge.pki.privateKeyToPem(privateKey);\r\n  }\r\n  // OpenSSH private key is just a legacy format, it seems\r\n  return forge.pki.encryptRsaPrivateKey(privateKey, passphrase,\r\n    {legacy: true, algorithm: 'aes128'});\r\n};\r\n\r\n/**\r\n * Gets the SSH fingerprint for the given public key.\r\n *\r\n * @param options the options to use.\r\n *          [md] the message digest object to use (defaults to forge.md.md5).\r\n *          [encoding] an alternative output encoding, such as 'hex'\r\n *            (defaults to none, outputs a byte buffer).\r\n *          [delimiter] the delimiter to use between bytes for 'hex' encoded\r\n *            output, eg: ':' (defaults to none).\r\n *\r\n * @return the fingerprint as a byte buffer or other encoding based on options.\r\n */\r\nssh.getPublicKeyFingerprint = function(key, options) {\r\n  options = options || {};\r\n  var md = options.md || forge.md.md5.create();\r\n\r\n  var type = 'ssh-rsa';\r\n  var buffer = forge.util.createBuffer();\r\n  _addStringToBuffer(buffer, type);\r\n  _addBigIntegerToBuffer(buffer, key.e);\r\n  _addBigIntegerToBuffer(buffer, key.n);\r\n\r\n  // hash public key bytes\r\n  md.start();\r\n  md.update(buffer.getBytes());\r\n  var digest = md.digest();\r\n  if(options.encoding === 'hex') {\r\n    var hex = digest.toHex();\r\n    if(options.delimiter) {\r\n      return hex.match(/.{2}/g).join(options.delimiter);\r\n    }\r\n    return hex;\r\n  } else if(options.encoding === 'binary') {\r\n    return digest.getBytes();\r\n  } else if(options.encoding) {\r\n    throw new Error('Unknown encoding \"' + options.encoding + '\".');\r\n  }\r\n  return digest;\r\n};\r\n\r\n/**\r\n * Adds len(val) then val to a buffer.\r\n *\r\n * @param buffer the buffer to add to.\r\n * @param val a big integer.\r\n */\r\nfunction _addBigIntegerToBuffer(buffer, val) {\r\n  var hexVal = val.toString(16);\r\n  // ensure 2s complement +ve\r\n  if(hexVal[0] >= '8') {\r\n    hexVal = '00' + hexVal;\r\n  }\r\n  var bytes = forge.util.hexToBytes(hexVal);\r\n  buffer.putInt32(bytes.length);\r\n  buffer.putBytes(bytes);\r\n}\r\n\r\n/**\r\n * Adds len(val) then val to a buffer.\r\n *\r\n * @param buffer the buffer to add to.\r\n * @param val a string.\r\n */\r\nfunction _addStringToBuffer(buffer, val) {\r\n  buffer.putInt32(val.length);\r\n  buffer.putString(val);\r\n}\r\n\r\n/**\r\n * Hashes the arguments into one value using SHA-1.\r\n *\r\n * @return the sha1 hash of the provided arguments.\r\n */\r\nfunction _sha1() {\r\n  var sha = forge.md.sha1.create();\r\n  var num = arguments.length;\r\n  for (var i = 0; i < num; ++i) {\r\n    sha.update(arguments[i]);\r\n  }\r\n  return sha.digest();\r\n}\r\n"]},"metadata":{},"sourceType":"script"}