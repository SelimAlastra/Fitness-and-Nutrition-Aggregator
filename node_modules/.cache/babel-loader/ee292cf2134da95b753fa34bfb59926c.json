{"ast":null,"code":"\"use strict\"; // Copyright 2013 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Compute = void 0;\n\nconst arrify = require(\"arrify\");\n\nconst gcpMetadata = require(\"gcp-metadata\");\n\nconst oauth2client_1 = require(\"./oauth2client\");\n\nclass Compute extends oauth2client_1.OAuth2Client {\n  /**\r\n   * Google Compute Engine service account credentials.\r\n   *\r\n   * Retrieve access token from the metadata server.\r\n   * See: https://developers.google.com/compute/docs/authentication\r\n   */\n  constructor(options = {}) {\n    super(options); // Start with an expired refresh token, which will automatically be\n    // refreshed before the first API call is made.\n\n    this.credentials = {\n      expiry_date: 1,\n      refresh_token: 'compute-placeholder'\n    };\n    this.serviceAccountEmail = options.serviceAccountEmail || 'default';\n    this.scopes = arrify(options.scopes);\n  }\n  /**\r\n   * Refreshes the access token.\r\n   * @param refreshToken Unused parameter\r\n   */\n\n\n  async refreshTokenNoCache( // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  refreshToken) {\n    const tokenPath = `service-accounts/${this.serviceAccountEmail}/token`;\n    let data;\n\n    try {\n      const instanceOptions = {\n        property: tokenPath\n      };\n\n      if (this.scopes.length > 0) {\n        instanceOptions.params = {\n          scopes: this.scopes.join(',')\n        };\n      }\n\n      data = await gcpMetadata.instance(instanceOptions);\n    } catch (e) {\n      e.message = `Could not refresh access token: ${e.message}`;\n      this.wrapError(e);\n      throw e;\n    }\n\n    const tokens = data;\n\n    if (data && data.expires_in) {\n      tokens.expiry_date = new Date().getTime() + data.expires_in * 1000;\n      delete tokens.expires_in;\n    }\n\n    this.emit('tokens', tokens);\n    return {\n      tokens,\n      res: null\n    };\n  }\n  /**\r\n   * Fetches an ID token.\r\n   * @param targetAudience the audience for the fetched ID token.\r\n   */\n\n\n  async fetchIdToken(targetAudience) {\n    const idTokenPath = `service-accounts/${this.serviceAccountEmail}/identity` + `?format=full&audience=${targetAudience}`;\n    let idToken;\n\n    try {\n      const instanceOptions = {\n        property: idTokenPath\n      };\n      idToken = await gcpMetadata.instance(instanceOptions);\n    } catch (e) {\n      e.message = `Could not fetch ID token: ${e.message}`;\n      throw e;\n    }\n\n    return idToken;\n  }\n\n  wrapError(e) {\n    const res = e.response;\n\n    if (res && res.status) {\n      e.code = res.status.toString();\n\n      if (res.status === 403) {\n        e.message = 'A Forbidden error was returned while attempting to retrieve an access ' + 'token for the Compute Engine built-in service account. This may be because the Compute ' + 'Engine instance does not have the correct permission scopes specified: ' + e.message;\n      } else if (res.status === 404) {\n        e.message = 'A Not Found error was returned while attempting to retrieve an access' + 'token for the Compute Engine built-in service account. This may be because the Compute ' + 'Engine instance does not have any permission scopes specified: ' + e.message;\n      }\n    }\n  }\n\n}\n\nexports.Compute = Compute;","map":{"version":3,"sources":["C:/Users/ibott/MajorGroupProject/node_modules/google-auth-library/build/src/auth/computeclient.js"],"names":["Object","defineProperty","exports","value","Compute","arrify","require","gcpMetadata","oauth2client_1","OAuth2Client","constructor","options","credentials","expiry_date","refresh_token","serviceAccountEmail","scopes","refreshTokenNoCache","refreshToken","tokenPath","data","instanceOptions","property","length","params","join","instance","e","message","wrapError","tokens","expires_in","Date","getTime","emit","res","fetchIdToken","targetAudience","idTokenPath","idToken","response","status","code","toString"],"mappings":"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","sourcesContent":["\"use strict\";\r\n// Copyright 2013 Google LLC\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//      http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Compute = void 0;\r\nconst arrify = require(\"arrify\");\r\nconst gcpMetadata = require(\"gcp-metadata\");\r\nconst oauth2client_1 = require(\"./oauth2client\");\r\nclass Compute extends oauth2client_1.OAuth2Client {\r\n    /**\r\n     * Google Compute Engine service account credentials.\r\n     *\r\n     * Retrieve access token from the metadata server.\r\n     * See: https://developers.google.com/compute/docs/authentication\r\n     */\r\n    constructor(options = {}) {\r\n        super(options);\r\n        // Start with an expired refresh token, which will automatically be\r\n        // refreshed before the first API call is made.\r\n        this.credentials = { expiry_date: 1, refresh_token: 'compute-placeholder' };\r\n        this.serviceAccountEmail = options.serviceAccountEmail || 'default';\r\n        this.scopes = arrify(options.scopes);\r\n    }\r\n    /**\r\n     * Refreshes the access token.\r\n     * @param refreshToken Unused parameter\r\n     */\r\n    async refreshTokenNoCache(\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    refreshToken) {\r\n        const tokenPath = `service-accounts/${this.serviceAccountEmail}/token`;\r\n        let data;\r\n        try {\r\n            const instanceOptions = {\r\n                property: tokenPath,\r\n            };\r\n            if (this.scopes.length > 0) {\r\n                instanceOptions.params = {\r\n                    scopes: this.scopes.join(','),\r\n                };\r\n            }\r\n            data = await gcpMetadata.instance(instanceOptions);\r\n        }\r\n        catch (e) {\r\n            e.message = `Could not refresh access token: ${e.message}`;\r\n            this.wrapError(e);\r\n            throw e;\r\n        }\r\n        const tokens = data;\r\n        if (data && data.expires_in) {\r\n            tokens.expiry_date = new Date().getTime() + data.expires_in * 1000;\r\n            delete tokens.expires_in;\r\n        }\r\n        this.emit('tokens', tokens);\r\n        return { tokens, res: null };\r\n    }\r\n    /**\r\n     * Fetches an ID token.\r\n     * @param targetAudience the audience for the fetched ID token.\r\n     */\r\n    async fetchIdToken(targetAudience) {\r\n        const idTokenPath = `service-accounts/${this.serviceAccountEmail}/identity` +\r\n            `?format=full&audience=${targetAudience}`;\r\n        let idToken;\r\n        try {\r\n            const instanceOptions = {\r\n                property: idTokenPath,\r\n            };\r\n            idToken = await gcpMetadata.instance(instanceOptions);\r\n        }\r\n        catch (e) {\r\n            e.message = `Could not fetch ID token: ${e.message}`;\r\n            throw e;\r\n        }\r\n        return idToken;\r\n    }\r\n    wrapError(e) {\r\n        const res = e.response;\r\n        if (res && res.status) {\r\n            e.code = res.status.toString();\r\n            if (res.status === 403) {\r\n                e.message =\r\n                    'A Forbidden error was returned while attempting to retrieve an access ' +\r\n                        'token for the Compute Engine built-in service account. This may be because the Compute ' +\r\n                        'Engine instance does not have the correct permission scopes specified: ' +\r\n                        e.message;\r\n            }\r\n            else if (res.status === 404) {\r\n                e.message =\r\n                    'A Not Found error was returned while attempting to retrieve an access' +\r\n                        'token for the Compute Engine built-in service account. This may be because the Compute ' +\r\n                        'Engine instance does not have any permission scopes specified: ' +\r\n                        e.message;\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.Compute = Compute;\r\n//# sourceMappingURL=computeclient.js.map"]},"metadata":{},"sourceType":"script"}